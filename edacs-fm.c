/*-------------------------------------------------------------------------------
 * EDACS-FM 
 * A program for decoding edacs/edacs extended addressing with esk
 * 
 * ASCII art generated by:
 * https://fsymbols.com/generators/carty/
 * 
 * Jail Ascii Art by:
 * https://ascii.co.uk/art/jail
 * 
 * Portions of this software originally from: 
 * https://github.com/sp5wwp/ledacs     
 * XTAL Labs
 * 30 IV 2016
 * Many thanks to SP5WWP for permission to use and modify this software
 * 
 * Encoder/decoder for binary BCH codes in C (Version 3.1)
 * Robert Morelos-Zaragoza
 * 1994-7
 * 
 * LWVMOBILE  
 * 2021-12 Version EDACS-FM Florida Man Edition
 *-----------------------------------------------------------------------------*/
#define _GNU_SOURCE

#include <stdio.h>

#include <unistd.h>

#include <limits.h>

#include <string.h>

#include <stdlib.h>

#include <arpa/inet.h>

#include <sys/types.h>

#include <sys/socket.h>

#include <netinet/in.h>

#include <fcntl.h>

#include <errno.h>

#include <time.h>

#include <ncurses.h>

#include <stdio_ext.h>

#include <math.h>

#include <netdb.h>

#include <sys/stat.h>

#include <pwd.h>

#include <termios.h>

#include <getopt.h>

#include <ctype.h>

#include <stdbool.h>

#include <locale.h>

#include "bch3.h" //experimental BCH support

#define BSIZE 999
#define UDP_BUFLEN 5 //maximum UDP buffer length
#define SRV_IP "127.0.0.1" //IP
#define UDP_PORT 6020 //UDP port

#define SAMP_NUM (48 + 6 * 40) * 2 * 3 //EDACS96 288-bit cycle
#define SYNC_FRAME 0x555557125555 << (64 - 48) //EDACS96 synchronization frame (12*4=48bit)
#define SYNC_MASK 0xFFFFFFFFFFFF << (64 - 48) //EDACS96 synchronization frame mask

unsigned long long sync_timeout = 3; //making sync_timeout a user definable variable now, default 3 seconds
unsigned char samples[SAMP_NUM]; //8-bit samples from rtl_fm (or rtl_udp)
signed short int raw_stream[SAMP_NUM / 2]; //16-bit signed int samples

signed int AFC = 2400; //Auto Frequency Control -> DC offset
signed int min = SHRT_MAX, max = SHRT_MIN; //min and max sample values
signed short int avg_arr[SAMP_NUM / 2 / 3]; //array containing 16-bit samples
unsigned int avg_cnt = 0; //avg array index variable

unsigned long long sr_0 = 0; //64-bit shift registers for pushing decoded binary data
unsigned long long sr_1 = 0; //288/64=4.5
unsigned long long sr_2 = 0; //
unsigned long long sr_3 = 0; //
unsigned long long sr_4 = 0; //

unsigned long long fr_1 = 0xFFFFFFFFFF; //40-bit shift registers for pushing decoded binary data
//unsigned long long fr_2 = 0; //each is a 40 bit message that repeats 3 times
//unsigned long long fr_3 = 0; //two messages per frame
unsigned long long fr_4 = 0xFFFFFFFFFF; //These are the human readable versions for debugging etc
//unsigned long long fr_5 = 0;
//unsigned long long fr_6 = 0;

//new BCH stuff
long long int fr_1m = 0xFFFFFFF; //28-bit 7X message portion to pass to bch handler
//long long int fr_1p = 0xFFF; //12-bit bch polynomial
long long int fr_1t = 0xFFFFFFFFFF; //combined fr_1m and fr_1p
long long int fr_4m = 0xFFFFFFF; //28-bit 7X message portion to pass to bch handler
//long long int fr_4p = 0xFFF; //12-bit bch polynomial
long long int fr_4t = 0xFFFFFFFFFF; //combined fr_4m and fr_4p
double good = 1;
double bad = 1; //don't set as 0 so we won't accidentally divide by 0 and blow up the universe
double gbr = 1;
//end new BCH stuff

unsigned short a_len = 4; //AFS allocation type
unsigned short f_len = 4; //bit lengths
unsigned short s_len = 3; //
unsigned short a_mask = 0x0; //and corresponding masks, set to 0 by default or they will accumulate when shifting
unsigned short f_mask = 0x0; //
unsigned short s_mask = 0x0; //

unsigned short x_mask = 0xA0;
unsigned short x_choice = 1;

unsigned long long afs = 0; //AFS 11-bit info
unsigned long long int patch_site = 0;
unsigned long long int site_id = 0;
unsigned long long int start_site_id = 0;

unsigned long long int tempsite_id = 999;
unsigned long long int tgroupx = 999;
signed long long int senderx = 0;
unsigned long long int groupx = 0;
signed long long int sourcep = 0;
signed long long int targetp = 0;
signed long long int patch_array[51][2]; //bump to 51 just in case
signed long long kicked = 0;
signed long long int tsenderx = 0;
unsigned long long tafs = 999;

//call_matrix 32 columns (lcns) with rows for time of call, group/afs, sender, and status
unsigned long long int call_matrix[33][4];
//group_matrix for groupname and mode
char * group_matrix[33][2];

char * mode_a;
char * mode_b;
int modecompare;
char * mode;
char * groupx_name;
char * site_name;
char * location_name;
unsigned char mt1 = 0x1F;
unsigned char mt2 = 0xF;
unsigned char mta = 0;

int adjust = 0; //next on the chopping block
int cyclecc = 0;
signed int ppm = 0;

unsigned int vcmd = 0x00; //voice command variable set by argument
unsigned int idcmd = 0x00;
unsigned char command = 0; //read from control channel
unsigned char lcn = 0;
unsigned char lcn_tally = 0;
unsigned char status = 0; //
unsigned char agency = 4, fleet = 4, subfleet = 3; // going to initialize with 4-4-3 scheme, most universal

char * sitecsv;
char * groupcsv;
int rfgain = 0;

unsigned long long int last_sync_time = 0; //last received sync timestamp
unsigned long long int last_voice_time = 0; //last received voice channel assignment timestamp

unsigned char current_lcn = 0; //current LCN
unsigned long long int LCN_list[32]; //LCN list
unsigned char cc = 1;

unsigned char deny_num = 0;
unsigned int deny_total = 0;
signed int deny_flag = 0;
short int udeny = 0;
short int allow = 0;

unsigned long long int CC_LCN = 0;
unsigned long long int hanguptime = 0;
unsigned long long int resettime = 0;
unsigned long long int logtime = 0;

char * FM_banner[14] = {

  "||   ||     ||   || ███████╗██████╗  █████╗  █████╗  ██████╗ ", 
  "||   ||, , ,||   || ██╔════╝██╔══██╗██╔══██╗██╔══██╗██╔════╝ ", 
  "||  (||/|/(|||/  || █████╗  ██║  ██║███████║██║  ╚═╝╚█████╗  ", 
  "||  ||| _'_`|||  || ██╔══╝  ██║  ██║██╔══██║██║  ██╗ ╚═══██╗ ",
  "||   || o o ||   || ███████╗██████╔╝██║  ██║╚█████╔╝██████╔╝ ",
  "||  (||  - `||)  || ╚══════╝╚═════╝ ╚═╝  ╚═╝ ╚════╝ ╚═════╝  ",
  "||   ||  =  ||   || ███████╗███╗   ███╗  Florida Man Edition ",
  "||   || (_) ||   || ██╔════╝████╗ ████║  Thanks to:          ",
  "||___||) , (||___|| █████╗  ██╔████╔██║    sp5wwp            ",
  "||---||- _ -||---|| ██╔══╝  ██║╚██╔╝██║    EricCottrell      ",
  "||--_||_____||_--|| ██║     ██║ ╚═╝ ██║    JSTARS03          ",
  "||)- |batdude| -(|| ╚═╝     ╚═╝     ╚═╝    blantonl          ",
  "|| | ||     |||  ||  ...and Robert Morelos-Zaragoza          "
};

signed int peer_counter = 0;
signed long long int peer_list[12];
signed long long int peer = 0;
unsigned long long int peer_lcn = 0;

//new CLI options for Site Extra, Call Matrix, Patches, and Logging
short int S = 0; //Display Site Extra in printw area
short int C = 0; //Display Call Matrix in printw area
short int P = 0; //Display Patches in printw area
short int Q = 0; //Enable logging of peers and patches
short int L = 0; //Enable voice call logging

signed int debug = 0; //debug value for printing out status and data on different command codes, etc

signed short int print_timeri = 10;

int handle; //for UDP
unsigned short port = UDP_PORT; 
char data[UDP_BUFLEN] = {
  0
}; 
struct sockaddr_in address; 

//--------------------------------------------
typedef struct key_value {
  char siteN[20];
  char location[20];
  char lcn0N[50];
  char lcn1N[50];
  char lcn2N[50];
  char lcn3N[50];
  char lcn4N[50];
  char lcn5N[50];
  char lcn6N[50];
  char lcn7N[50];
  char lcn8N[50];
  char lcn9N[50]; 
  char lcn10N[50];
  char lcn11N[50];
  char lcn12N[50];
  char lcn13N[50];
  char lcn14N[50];
  char lcn15N[50];
  char lcn16N[50];
  char lcn17N[50];
  char lcn18N[50];
  char lcn19N[50];
  char lcn20N[50];
  char lcn21N[50];
  char lcn22N[50];
  char lcn23N[50];
  char lcn24N[50];
  char lcn25N[50];
  char lcn26N[50];
  char lcn27N[50];
  char lcn28N[50];
  char lcn29N[50];
  char lcn30N[50];
  char lcn31N[50];

}
dict;

void loadLCN(int tsite_id, dict site_array[]) //load LCN frequencies from csv importer/struct
{
  LCN_list[0] = atoi(site_array[tsite_id].lcn0N);
  LCN_list[1] = atoi(site_array[tsite_id].lcn1N);
  LCN_list[2] = atoi(site_array[tsite_id].lcn2N);
  LCN_list[3] = atoi(site_array[tsite_id].lcn3N);
  LCN_list[4] = atoi(site_array[tsite_id].lcn4N);
  LCN_list[5] = atoi(site_array[tsite_id].lcn5N);
  LCN_list[6] = atoi(site_array[tsite_id].lcn6N);
  LCN_list[7] = atoi(site_array[tsite_id].lcn7N);
  LCN_list[8] = atoi(site_array[tsite_id].lcn8N);
  LCN_list[9] = atoi(site_array[tsite_id].lcn9N);
  LCN_list[10] = atoi(site_array[tsite_id].lcn10N);
  LCN_list[11] = atoi(site_array[tsite_id].lcn11N);
  LCN_list[12] = atoi(site_array[tsite_id].lcn12N);
  LCN_list[13] = atoi(site_array[tsite_id].lcn13N);
  LCN_list[14] = atoi(site_array[tsite_id].lcn14N);
  LCN_list[15] = atoi(site_array[tsite_id].lcn15N);
  LCN_list[16] = atoi(site_array[tsite_id].lcn16N);
  LCN_list[17] = atoi(site_array[tsite_id].lcn17N);
  LCN_list[18] = atoi(site_array[tsite_id].lcn18N);
  LCN_list[19] = atoi(site_array[tsite_id].lcn19N);
  LCN_list[20] = atoi(site_array[tsite_id].lcn20N);
  LCN_list[21] = atoi(site_array[tsite_id].lcn21N);
  LCN_list[22] = atoi(site_array[tsite_id].lcn22N);
  LCN_list[23] = atoi(site_array[tsite_id].lcn23N);
  LCN_list[24] = atoi(site_array[tsite_id].lcn24N);
  LCN_list[25] = atoi(site_array[tsite_id].lcn25N);
  LCN_list[26] = atoi(site_array[tsite_id].lcn26N);
  LCN_list[27] = atoi(site_array[tsite_id].lcn27N);
  LCN_list[28] = atoi(site_array[tsite_id].lcn28N);
  LCN_list[29] = atoi(site_array[tsite_id].lcn29N);
  LCN_list[30] = atoi(site_array[tsite_id].lcn30N);
  LCN_list[31] = atoi(site_array[tsite_id].lcn31N);
  site_name = site_array[tsite_id].siteN;
  location_name = site_array[tsite_id].location;
}

int csvImport() {
  char filename[] = "site.csv";
  strcpy(filename, sitecsv);
  char buffer[BSIZE];
  FILE * fp;
  fp = fopen(filename, "r");
  if (fp == NULL) {
    printf("Unable to open file '%s'\n", filename);
    exit(1);
  }
  int row_count = 0;
  int field_count = 0;
  dict site_array[9999]; //array to struct to store values
  int tsite_id = site_id;

  while (fgets(buffer, BSIZE, fp)) {
    field_count = 0;
    row_count++;
    if (row_count == 1)
      continue; //don't want labels
    char * field = strtok(buffer, ","); //seperate by comma
    int i = atoi(field); //field is seeing site id, make dict based on i value for site id, then cross reference later on for LCN
    while (field) {
      if (field_count == 0)
        strcpy(site_array[i].siteN, field);

      if (field_count == 1)
        strcpy(site_array[i].location, field);

      if (field_count == 2)
        strcpy(site_array[i].lcn0N, field);

      if (field_count == 3)
        strcpy(site_array[i].lcn1N, field);

      if (field_count == 4)
        strcpy(site_array[i].lcn2N, field);

      if (field_count == 5)
        strcpy(site_array[i].lcn3N, field);

      if (field_count == 6)
        strcpy(site_array[i].lcn4N, field);

      if (field_count == 7)
        strcpy(site_array[i].lcn5N, field);

      if (field_count == 8)
        strcpy(site_array[i].lcn6N, field);

      if (field_count == 9)
        strcpy(site_array[i].lcn7N, field);

      if (field_count == 10)
        strcpy(site_array[i].lcn8N, field);

      if (field_count == 11)
        strcpy(site_array[i].lcn9N, field);

      if (field_count == 12)
        strcpy(site_array[i].lcn10N, field);

      if (field_count == 13)
        strcpy(site_array[i].lcn11N, field);

      if (field_count == 14)
        strcpy(site_array[i].lcn12N, field);

      if (field_count == 15)
        strcpy(site_array[i].lcn13N, field);

      if (field_count == 16)
        strcpy(site_array[i].lcn14N, field);

      if (field_count == 17)
        strcpy(site_array[i].lcn15N, field);

      if (field_count == 18)
        strcpy(site_array[i].lcn16N, field);

      if (field_count == 19)
        strcpy(site_array[i].lcn17N, field);

      if (field_count == 20)
        strcpy(site_array[i].lcn18N, field);

      if (field_count == 21)
        strcpy(site_array[i].lcn19N, field);

      if (field_count == 22)
        strcpy(site_array[i].lcn20N, field);

      if (field_count == 23)
        strcpy(site_array[i].lcn21N, field);

      if (field_count == 24)
        strcpy(site_array[i].lcn22N, field);

      if (field_count == 25)
        strcpy(site_array[i].lcn23N, field);

      if (field_count == 26)
        strcpy(site_array[i].lcn24N, field);

      if (field_count == 27)
        strcpy(site_array[i].lcn25N, field);

      if (field_count == 28)
        strcpy(site_array[i].lcn26N, field);

      if (field_count == 29)
        strcpy(site_array[i].lcn27N, field);

      if (field_count == 30)
        strcpy(site_array[i].lcn28N, field);

      if (field_count == 31)
        strcpy(site_array[i].lcn29N, field);

      if (field_count == 32)
        strcpy(site_array[i].lcn30N, field);

      if (field_count == 33)
        strcpy(site_array[i].lcn31N, field);

      field = strtok(NULL, ",");
      field_count++;
    }
  }
  fclose(fp);
  loadLCN(tsite_id, site_array);

  return 0;
}
typedef struct key_v {

  signed long long int groupNumber;
  char groupMode[8];
  char groupName[50];

}
groupinfo;

void loadGroupMatrix(unsigned char tlcn, signed long long int tgroup_id, groupinfo group_array[]) {
  group_matrix[tlcn][0] = group_array[tgroup_id].groupName;
  group_matrix[tlcn][1] = group_array[tgroup_id].groupMode;
  groupx_name = group_array[tgroup_id].groupName;
  mode = group_array[tgroup_id].groupMode;

}

signed long long int csvGroupImport() {
  char filename[] = "group.csv";
  strcpy(filename, groupcsv);
  char buffer[BSIZE];
  FILE * fp;
  fp = fopen(filename, "r");
  if (fp == NULL) {
    printf("Unable to open file '%s'\n", filename);
    exit(1);
  }
  long long int row_count = 0;
  int field_count = 0;
  groupinfo group_array[67000]; //array to struct to store values
  signed long long int tgroup_id2 = groupx;
  unsigned char tlcn2 = lcn; 
  while (fgets(buffer, BSIZE, fp)) {
    field_count = 0;
    row_count++;
    if (row_count == 1)
      continue; //don't want labels
    char * field = strtok(buffer, ","); //seperate by comma
    signed long long int i = atoi(field); //field is seeing site id, make dict based on i value for site id, then cross reference later on for LCN
    while (field) {
      if (field_count == 0)
        group_array[i].groupNumber = atoi(field);

      if (field_count == 1)
        strcpy(group_array[i].groupMode, field);

      if (field_count == 2)
        strcpy(group_array[i].groupName, field);

      field = strtok(NULL, ",");
      field_count++;
    }
  }
  fclose(fp);
  loadGroupMatrix(tlcn2, tgroup_id2, group_array);
  return 0;
}
int init_udp() //UDP init
{
  handle = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

  if (handle <= 0) {
    printf("Failed to create socket\n");
    return 1;
  }

  printf("Sockets successfully initialized\n");

  memset((char * ) & address, 0, sizeof(address));

  address.sin_family = AF_INET;
  address.sin_addr.s_addr = inet_addr(SRV_IP); //address of host
  address.sin_port = htons(port);

  return 0;
}

char * getTime(void) //get pretty hh:mm:ss timestamp
{
  time_t t = time(NULL);

  char * curr;
  char * stamp = asctime(localtime( & t));

  curr = strtok(stamp, " ");
  curr = strtok(NULL, " ");
  curr = strtok(NULL, " ");
  curr = strtok(NULL, " ");

  return curr;
}

char * getDate(void) {
  char datename[32];
  char * curr2;
  struct tm * to;
  time_t t;
  t = time(NULL);
  to = localtime( & t);
  strftime(datename, sizeof(datename), "%Y-%m-%d", to);
  curr2 = strtok(datename, " ");
  return curr2;
}
//--------------------------------------------
void tune(unsigned long long int freq) //tuning to LCN freq
{
  data[0] = 0;
  data[1] = freq & 0xFF;
  data[2] = (freq >> 8) & 0xFF;
  data[3] = (freq >> 16) & 0xFF;
  data[4] = (freq >> 24) & 0xFF;

  sendto(handle, data, UDP_BUFLEN, 0, (const struct sockaddr * ) & address, sizeof(struct sockaddr_in));
}

void tuneCC(unsigned long long int ccfreq) //tuning to CC freq, only works with PyEDACS tuner, not rtl_udp
{
  data[0] = 9;
  data[1] = ccfreq & 0xFF;
  data[2] = (ccfreq >> 8) & 0xFF;
  data[3] = (ccfreq >> 16) & 0xFF;
  data[4] = (ccfreq >> 24) & 0xFF;

  sendto(handle, data, UDP_BUFLEN, 0, (const struct sockaddr * ) & address, sizeof(struct sockaddr_in));
}
//rework ppmAdjust just for initial ppm correction, and not for self adjustments, change argument to required and send data to pyEdacs, see gainSet
void ppmAdjust(unsigned long long int ccppm) //adjustments to CC PPM, only works with PyEDACS tuner, not rtl_fm/udp
{
  data[0] = 7;
  data[1] = ccppm & 0xFF;
  data[2] = (ccppm >> 8) & 0xFF;
  data[3] = (ccppm >> 16) & 0xFF;
  data[4] = (ccppm >> 24) & 0xFF;

  sendto(handle, data, UDP_BUFLEN, 0, (const struct sockaddr * ) & address, sizeof(struct sockaddr_in));
}

void squelchSet(unsigned long long int sq) //squelch
{
  data[0] = 2;
  data[1] = sq & 0xFF;
  data[2] = (sq >> 8) & 0xFF;
  data[3] = (sq >> 16) & 0xFF;
  data[4] = (sq >> 24) & 0xFF;

  sendto(handle, data, UDP_BUFLEN, 0, (const struct sockaddr * ) & address, sizeof(struct sockaddr_in));
}

void gainSet(int gain) //adjustments to RF Gain in PyEDACS tuner, may also function in rtl_udp
{
  data[0] = 3; // 3 on rtl_udp is for new_gain, so maybe works with both, unsure yet, 8 is AGC mode
  data[1] = gain & 0xFF;
  data[2] = (gain >> 8) & 0xFF;
  data[3] = (gain >> 16) & 0xFF;
  data[4] = (gain >> 24) & 0xFF;

  sendto(handle, data, UDP_BUFLEN, 0, (const struct sockaddr * ) & address, sizeof(struct sockaddr_in));
}

void FM() //Print a swanky ascii art banner
{

  for (short int i = 0; i < 13; i++) {
    printf("%s \n", FM_banner[i]);
  }
}
//need to work this back into future release
void print_usage(char * name) {

  printf("Usage:\n");
  exit(EXIT_FAILURE);
}
bool ParseInputOptions(int argc, char ** argv) {
  int c;

  while (1) {
    static struct option long_options[] = {
      /* These options set a flag. */
      //{"verbose", no_argument,       &opt_verbose, 1},
      /* These options don’t set a flag.
         We distinguish them by their indices. */
      {"Sync Timeout",          required_argument,0,'t'},
      {"Universal Denial",      no_argument,0,'d'},
      {"verbose",               no_argument,0,'v'},
      {"legacy",                no_argument,0,'l'},
      {"esk",                   no_argument,0,'e'},
      {"ea",                    no_argument,0,'E'},
      {"esk-ea",                no_argument,0,'x'},
      {"afs A bit",             required_argument,0,'a'},
      {"afs F bit",             required_argument,0,'f'},
      {"siteinfo",              required_argument,0,'s'},
      {"sitenumber",            required_argument,0,'c'},
      {"group",                 required_argument,0,'g'},
      {"RF gain",               required_argument,0,'r'},
      {"ppm-auto-adjustments",  no_argument,0,'p'},
      {"Site Extra",            no_argument,0,'S'},
      {"Call Matrix",           no_argument,0,'C'},
      {"Patches",               no_argument,0,'P'},
      {"P Log",                 no_argument,0,'Q'},
      {"Call Log",              no_argument,0,'L'},
      {0,0,0,0}
    };
    /* getopt_long stores the option index here. */
    int option_index = 0;

    c = getopt_long(argc, argv, "t: d v l e E x a:f:s:c:g:r:p S C P Q L",
      long_options, & option_index);

    // warning: need to use : after required arguments, no colon for optional ones
    //          if a following option is encountered getopt_long returns this option as the argument in optarg 
    //          instead of error, but if there is only one option with a missing arg then it returns an error.
    //          

    /* Detect the end of the options. */
    if (c == -1)
      break;

    switch (c) {
    case 0:
      /* If this option set a flag, do nothing else now. */
      if (long_options[option_index].flag != 0)
        break;
      printf("option %s", long_options[option_index].name);
      if (optarg)
        printf(" with arg %s", optarg);
      printf("\n");
      break;
    case 't':
      sync_timeout = atol(optarg);
      printf("Sync Timeout = [%lld] seconds\n", sync_timeout);
      break;  
    case 'd':
      udeny = 1;
      printf("Universal Denial Mode Set - Only groups with mode [A] will be granted voice channel\n");
      break;
    case 'v':
      debug = 3;
      printf("Verbosity Mode Enabled - Debug set to 3 \n");
      break;
    case 'x':
      printf("Extended Addressing with ESK Mode Enabled \n");
      x_mask = 0xA0; //XOR for ESK
      idcmd = 0xFD;
      vcmd = 0xB8; //not using commands anymore for EA, but correcting this anyways
      x_choice = 1;
      break;
    case 'E':
      printf("Extended Addressing Mode Enabled \n"); //Extended Addressing without ESK, noticed a new trend lately
      x_mask = 0x0; 
      idcmd = 0xFD;
      vcmd = 0xB8;
      x_choice = 1;
      break;
    case 'e':
      printf("ESK Mode Enabled \n");
      x_mask = 0xA0; //XOR for ESK
      idcmd = 0xFD;
      vcmd = 0xEE;
      x_choice = 2;
      break;
    case 'l':
      printf("EDACS Standard Mode Enabled \n");
      x_mask = 0x0; //no XOR for legacy
      vcmd = 0xEE;
      idcmd = 0xFD;
      x_choice = 2;
      break;
    case 'a':
      a_len = atol(optarg);
      printf("Agency bit setting = [%d] bits\n", a_len);
      break;
    case 'f':
      f_len = atol(optarg);
      printf("Fleet bit setting = [%d] bits\n", f_len);
      break;
    case 's':
      if (optarg[0] == '-') {
        printf("Error: -%c: option requires an argument\n", c);
        print_usage(argv[0]);
      }
      sitecsv = optarg;
      printf("Site CSV File name = %s \n", sitecsv);
      break;
    case 'c':
      start_site_id = atol(optarg); //need to change to same as 's' type to prevent segfault when not specified argument
      printf("Site ID CC to Hunt For = [%lld] \n", start_site_id);
      break;
    case 'g':
      if (optarg[0] == '-') {
        printf("Error: -%c: option requires an argument\n", c);
        print_usage(argv[0]);
      }
      groupcsv = optarg;
      printf("Group CSV File name = %s \n", groupcsv);
      break;
    case 'r':
      if (optarg[0] == '-') {
        printf("Error: -%c: option requires an argument\n", c);
        print_usage(argv[0]);
      }
      rfgain = atoi(optarg);
      printf("RF Gain = %d \n", rfgain);
      break;
    case 'p':
      adjust = 1;
      printf("AFC/PPM auto adjust enabled - warning, highly temperamental \n");
      break;
    case 'S':
      S = 1;
      printf("Site Extra Display Enabled \n");
      break;
    case 'C':
      C = 1;
      printf("Call Matrix Display Enabled \n");
      break;
    case 'P':
      P = 1;
      printf("Patch Display Enabled \n");
      break;
    case 'Q':
      Q = 1;
      printf("Patch and Peers Logging Enabled \n");
      break;
    case 'L':
      L = 1;
      printf("Voice Call Logging Enabled \n");
      break;
    }
  }
}

//--------------------------------------------MAIN--------------------------------------
int main(int argc, char ** argv) {
  setlocale(LC_ALL, "");
  FM();
  read_p();               //Read m 
  generate_gf();          //Construct the Galois Field GF(2**m)	
  gen_poly();			  //Compute the generator polynomial of BCH code 
  printf("Galois Field GF(2**m) Constructed. Generator Polynomial Computed.\n"); 
  printf("40-28-6-2 BCH Scheme for Error Detection and Correction.\n");
  cc = 0;
  groupcsv = "group.csv";
  sitecsv = "site.csv";
  resettime = time(NULL);
  logtime = time(NULL) - 540;
  ParseInputOptions(argc, argv);
  signed int avg = 0; //sample average
  s_len = 11 - (a_len + f_len);
  if (x_choice == 2) {
    printf("Subfleet bit setting = [%X] bits \n", s_len);
    for (unsigned short int i = 0; i < a_len; i++) //A
    {
      a_mask = a_mask << 1;
      a_mask |= 1;
    }
    a_mask = a_mask << (11 - a_len);
    printf("a_mask = [%X] \n", a_mask);
    for (unsigned short int i = 0; i < f_len; i++) //F
    {
      f_mask = f_mask << 1;
      f_mask |= 1;
    }
    f_mask = f_mask << s_len;
    printf("f_mask = [%X] \n", f_mask);
    for (unsigned short int i = 0; i < s_len; i++) //S
    {
      s_mask = s_mask << 1;
      s_mask |= 1;
    }
    printf("s_mask = [%X] \n", s_mask);
  }
  init_udp();

  sleep(1); //patience is a virtue
  //if gain specified by user, then change gain in PyEDACS from default value
  squelchSet(5000);
  if (rfgain > 0) {
    gainSet(rfgain);
  }
  //When using PyEDACS and changing site you want to monitor, this will set to a presumably empty channel so it won't be stuck on the last monitored channel
  if (start_site_id > 0) {
    tuneCC(850000000);
  }
  last_sync_time = time(NULL);
  last_voice_time = time(NULL);
  unsigned char voice_to = 0; //0 - no timeout active, 1 - last voice channel assignment more than VOICE_TIMEOUT seconds ago, inactive

  for (int i = 0; i < SAMP_NUM / 2 / 3 - 1; i++) //zero array
  {
    avg_arr[i] = 0;
  }

  //let's get the party started
  while (1) {
    initscr(); //Initialize NCURSES screen window
    start_color();
    init_pair(1, COLOR_YELLOW, COLOR_BLACK);      //Yellow/Amber for frame sync/control channel, NV style
    init_pair(2, COLOR_RED, COLOR_BLACK);        //Red for Terminated Calls
    init_pair(3, COLOR_GREEN, COLOR_BLACK);     //Green for Active Calls
    init_pair(4, COLOR_CYAN, COLOR_BLACK);     //Cyan for Patches or any Extra Info
    init_pair(5, COLOR_MAGENTA, COLOR_BLACK); //Magenta for no frame sync/signal
    noecho();
    cbreak();
    if ((time(NULL) - hanguptime) > 30) { //extending to 30 seconds just in case dot detection doesn't catch, or long winded caller
      squelchSet(5000); 
    }

    if ((time(NULL) - last_sync_time) > sync_timeout) //Check to see if control channel is still there
    {
      erase();
      attron(COLOR_PAIR(5));
      for (short int i = 0; i < 13; i++) {
        printw("%s \n", FM_banner[i]);
      }
      attroff(COLOR_PAIR(5));
      printw("Control Channel not found/lost. Timeout. Waiting...\n");
      last_sync_time = time(NULL);
      kicked = 0;
      targetp = 0;
      sourcep = 0;
      peer = 0;
      good = 1;
      bad = 1;
      gbr = 1; //"zero" out good bad and gbr
      //reset log peers and patches when signal time out
      if (x_choice == 1 && patch_array[0][0] > 0 && Q == 1) { //check patch_array to see if anything is in it, otherwise, will keep logging blanks until signal regained
        FILE * pFile;
        pFile = fopen("pandp.log", "a");
        fprintf(pFile, "%s %s SITE %3lld Signal Loss Logging \n", getDate(), getTime(), tempsite_id);
        fprintf(pFile, "Peer Sites ");
        for (short int i = 0; i < 12; i++) {
          if (peer_list[i] > 0) {
            fprintf(pFile, "[%lld]", peer_list[i]);
          }
        }
        fprintf(pFile, "\n");
        for (short int i = 0; i < 49; i++) {
          if (patch_array[i][0] > 0) {
            fprintf(pFile, "Patch Group #%2d [%5lld] to [%5lld]", i + 1, patch_array[i][1], patch_array[i][0]);
            fprintf(pFile, "\n");
          }
        }
        fclose(pFile);
      }
      //end logging peers and patches before wipe
      for (short int i = 0; i < 12; i++) { //zero out peer_list
        peer_list[i] = 0;
      }
      for (short int i = 0; i < 49; i++) { //zero out patch_array
        patch_array[i][0] = 0;
        patch_array[i][1] = 0;
      }
      patch_site = 0;
      tempsite_id = 999;
      lcn_tally = 0;
      resettime = time(NULL);
      logtime = time(NULL) - 540; 
      if (start_site_id == 0) {
        site_id = 0;
        site_name = "Searching";
        location_name = "Searching";
      }
      if (start_site_id > 0) {
        printw("Attemping to tune Site [%d] LCNs to find Control Channel\n", start_site_id);
        site_id = start_site_id;
        csvImport();
        if (cyclecc > -1 && cyclecc < 31) { //cycle through a possibility of 32 LCN channels in the sites.csv file
          if (LCN_list[cyclecc] > 1) {
            tuneCC(LCN_list[cyclecc]);
            printw("LCN Freq: [%d]", LCN_list[cyclecc]);
            cyclecc = cyclecc + 1;
            refresh();
            sleep(2);
          }
        }
        if (LCN_list[cyclecc] == 0) { //if no more frequencies in sites.csv, jump back to beginning of cycle
          cyclecc = 0;
        }
        if (cyclecc > 31) { //if cyclecc exceeds 31, jump back to beginning, assuming there are 32 LCN channels specified
          cyclecc = 0;
        }
      }
      refresh();

    }

    read(0, samples, 3 * 2); //read 3 samples (6 unsigned chars)
    raw_stream[0] = (signed short int)((samples[0 + 1] << 8) | (samples[0] & 0xFF));
    raw_stream[1] = (signed short int)((samples[2 + 1] << 8) | (samples[2] & 0xFF));
    raw_stream[2] = (signed short int)((samples[4 + 1] << 8) | (samples[4] & 0xFF));
    avg = (raw_stream[0] + raw_stream[1] + raw_stream[2]) / 3; //

    //AFC recomputing using averaged samples
    avg_arr[avg_cnt] = avg;
    avg_cnt++;
    if (avg_cnt >= SAMP_NUM / 2 / 3 - 1) //reset after filling avg_array
    {
      avg_cnt = 0;
      min = SHRT_MAX;
      max = SHRT_MIN;

      for (int i = 0; i < SAMP_NUM / 2 / 3 - 1; i++) //simple min/max detector
      {
        if (avg_arr[i] > max)
          max = avg_arr[i];
        if (avg_arr[i] < min)
          min = avg_arr[i];
      }
      AFC = (min + max) / 2;

    }
    //--------------------------------------
    //pushing data into shift registers
    sr_0 = (sr_0 << 1) | (sr_1 >> 63);
    sr_1 = (sr_1 << 1) | (sr_2 >> 63);
    sr_2 = (sr_2 << 1) | (sr_3 >> 63);
    sr_3 = (sr_3 << 1) | (sr_4 >> 63);
    sr_4 = sr_4 << 1;

    if (avg < AFC)
      sr_4 |= 1;
    //---------------------------------

    if ((sr_0 & SYNC_MASK) == SYNC_FRAME) //extract data after receiving the sync frame
    {
      //put sr data in human readable/easier to work with fr 40 bit (10 hex) messages
      //disabling all but fr_1 and fr_4 due to BCH enabled, no need for extra redundancy
      //will leave these values here for future reference, or if needed
      fr_1 = ((sr_0 & 0xFFFF) << 24) | ((sr_1 & 0xFFFFFF0000000000) >> 40);
      //fr_2 = sr_1 & 0xFFFFFFFFFF;
      //fr_3 = (sr_2 & 0xFFFFFFFFFF000000) >> 24;
      fr_4 = ((sr_2 & 0xFFFFFF) << 16) | ((sr_3 & 0xFFFF000000000000) >> 48);
      //fr_5 = ((sr_3 & 0xFFFFFFFFFF00) >> 8);
      //fr_6 = ((sr_3 & 0xFF) << 32) | ((sr_4 & 0xFFFFFFFF00000000) >> 32);
      
      //new BCH Stuff
      fr_1m = (fr_1 & 0xFFFFFFF000) >> 12;    //message portion to send to bch to calc polynomial
	  BCH(fr_1m);                            //send through the bch
	  fr_1t = messagepp & 0xFFFFFFFFFF;     //return from the bch 
	  fr_4m = (fr_4 & 0xFFFFFFF000) >> 12; //message portion to send to bch to calc polynomial
	  BCH(fr_4m);                         //send through the bch 
	  fr_4t = messagepp & 0xFFFFFFFFFF;  //return from the bch 
	  //end new BCH Stuff

      if (fr_1 != fr_1t || fr_4 != fr_4t){ //BCH error detection up top to trickle down
		bad = bad + 1; } //tally number of bad frames
		
      if (fr_1 == fr_1t && fr_4 == fr_4t) //both fr_1 and fr_4 have to pass poly test
      {
		good = good + 1; //tally number of good frames
		gbr = ( good / (good + bad) ); //makeshift SNR counter for good / good + bad
        command = ((fr_1t & 0xFF00000000) >> 32) ^ x_mask;
        if (x_choice == 1) {
          lcn = (fr_1t & 0x3E0000000) >> 29; 
          mt1 = (command & 0xF8) >> 3;
          mt2 = (fr_1t & 0x780000000) >> 31;
        }
        //AFS and status for standard should all be moved to calling block eventually
        if (x_choice == 2) { //funky formatting is for easier visualizing on where to apply masking
          status  = (fr_1t & 0xF00000000) >> 32;
             lcn  =  (fr_1t & 0xF8000000) >> 27;
             afs  =    (fr_1t & 0x7FF000) >> 12;
          //leaving this for my personal reference
          //a_mask = 0x780; 4
          //f_mask = 0x078; 4 
          //s_mask = 0x007; 3
          //AFS =  0x625 <- first hex always has to be 7 or less, so don't mask with F, mask with 7
          //4      0x780 >> 3 + 4 or (11 = a_len) 
          //3      0x070 >> 4 + 1 or (f_mask << s_len)
          //4      0x00F just use afs & a_mask
          agency = (afs & a_mask) >> (11 - a_len);
          fleet = (afs & f_mask) >> s_len;
          subfleet = (afs & s_mask);
        }

        if (x_choice == 1 && mt1 == 0x1f && mt2 == 0xA) //SITE ID for EA systems
        {
          site_id = ((fr_1t & 0x1F000) >> 12) | ((fr_1t & 0x1F000000) >> 19);
          if (site_id != tempsite_id) {
            lcn_tally = 0;
            peer = 0;
            //log peers and patches if site id changes suddenly and site_id not equal to 0 i.e. SDR++ or GQRX signal
            if (site_id > 0 && tempsite_id != 999 && x_choice == 1 && patch_array[0][0] > 0 && Q == 1) { //check patch_array to see if anything is in it, otherwise, will keep logging blanks until signal regained
              FILE * pFile;
              pFile = fopen("pandp.log", "a");
              fprintf(pFile, "%s %s SITE %3lld Site ID changed to %3lld\n", getDate(), getTime(), tempsite_id, site_id);
              fprintf(pFile, "Peer Sites ");
              for (short int i = 0; i < 12; i++) {
                if (peer_list[i] > 0) {
                  fprintf(pFile, "[%lld]", peer_list[i]);
                }
              }
              fprintf(pFile, "\n");
              for (short int i = 0; i < 49; i++) {
                if (patch_array[i][0] > 0) {
                  fprintf(pFile, "Patch Group #%2d [%5lld] to [%5lld]", i + 1, patch_array[i][1], patch_array[i][0]);
                  fprintf(pFile, "\n");
                }
              }
              fclose(pFile);
              logtime = time(NULL) - 540;
            }
            for (short int i = 0; i < 12; i++) { //zero out peer_list
              peer_list[i] = 0;
            }
            for (short int i = 0; i < 49; i++) { //zero out patch_array
              patch_array[i][0] = 0;
              patch_array[i][1] = 0;
            }
            csvImport();
            tempsite_id = site_id;
          }
        }
        
        if (command == idcmd && x_choice == 2) { //SITE ID for Standard/Networked
          site_id = (fr_1t & 0xFF000) >> 12;
          if (site_id != tempsite_id) {
            csvImport();
            tempsite_id = site_id;
          }
        }
        
        if (mt1 == 0x1F && mt2 == 0xC) //PATCH LISTING for EA Systems
        {
          patch_site = ((fr_4t & 0xFF00000000) >> 32); //I don't even remember or know if this is valid info
          targetp = ((fr_4t & 0xFFFF000) >> 12);
          sourcep = ((fr_1t & 0xFFFF000) >> 12);
          //Make 2D array with Patches in it
          short int p = 0;
          while (p < 49) {
            if (patch_array[p][0] > 0) {
              if (patch_array[p][0] == targetp && patch_array[p][1] == sourcep && targetp != sourcep) { //try checking by both values, and not just targetp
                break;
              }
            }
            if (patch_array[p][0] == 0) {
              patch_array[p][0] = targetp;
              patch_array[p][1] = sourcep;
              break;
            }
            p++;
          }
        }
        
        if (x_choice == 1 && mt1 == 0x1F && mt2 == 0xB) //KICK LISTING for EA systems
        {
          kicked = (fr_4t & 0xFFFFF000) >> 12;
        }
        
        if (x_choice == 1 && mt1 == 0x1F && mt2 == 0x1 && ((fr_1 & 0xFF000) >> 12) > 0) { //PEER LISTING on EA systems
          peer = (fr_1t & 0xFF000) >> 12;
          peer_lcn = (fr_1t & 0x1F000000) >> 24;
          //Make Small Array with Peers in it
          short int p = 0;
          while (p < 12) {
            if (peer_list[p] > 0) {
              if (peer_list[p] == peer) {
                break;
              }
            }
            if (peer_list[p] == 0) {
              peer_list[p] = peer;
              break;
            }
            p++;
          }
        }
        
        if (x_choice == 1 && mt1 == 0x1F && mt2 == 0x8){ //Find Control Channel LCN on EA systems

          if (((fr_4t >> 12) & 0x1F) != 0) {
            CC_LCN = ((fr_4t >> 12) & 0x1F);
            if (CC_LCN > lcn_tally) {
              lcn_tally = CC_LCN;
            }
          }
        }

        if (x_choice == 2 && command == 0xFD) { //Find Control Channel LCN on Standard/Networked
          CC_LCN = (fr_1t & 0x1F000000) >> 24;
        }

        if (time(NULL) - resettime > 1215) { //reset lcn_tally, peers, patches after 20 minutes 15 seconds, give just enough time for 2 pandp logs
          lcn_tally = 0;
          for (short int i = 0; i < 12; i++) { //zero out peer_list
            peer_list[i] = 0;
          }
          for (short int i = 0; i < 49; i++) { //zero out patch_array
            patch_array[i][0] = 0;
            patch_array[i][1] = 0;
          }

          resettime = time(NULL);
        }
        // log peers and patches after one minute of collection, then 10 minutes afterwards, logtime initialized with +540 seconds on startup
        if ((time(NULL) - logtime > 600) && x_choice == 1 && Q == 1) {
          FILE * pFile;
          pFile = fopen("pandp.log", "a");
          fprintf(pFile, "%s %s SITE %3lld Log Time\n", getDate(), getTime(), tempsite_id);
          fprintf(pFile, "Peer Sites ");
          for (short int i = 0; i < 12; i++) {
            if (peer_list[i] > 0) {
              fprintf(pFile, "[%lld]", peer_list[i]);
            }
          }
          fprintf(pFile, "\n");
          for (short int i = 0; i < 49; i++) {
            if (patch_array[i][0] > 0) {
              fprintf(pFile, "Patch Group #%2d [%5lld] to [%5lld]", i + 1, patch_array[i][1], patch_array[i][0]);
              fprintf(pFile, "\n");
            }
          }
          fclose(pFile);
          logtime = time(NULL);
        }
        
        if (command == idcmd && print_timeri < 0) //IDLE, print_timeri just for the voice_to bs
        {
          if (voice_to == 0) //1 for inactive (backwards, I know) 
          {
            voice_to = 1; //1 - idle
          }
        }
        
        //0x3 is Digital group voice call, 0x2 Group Data Channel, 0x1 TDMA call, 0xE Standard/Networked Analog, 0xF Standard/Networked Digital
        if ( (x_choice == 1 && mt1 >= 0x1 && mt1 <= 0x3) || (x_choice == 2 && (command == 0xEE || command == 0xEF)) ){ //LCN CALLS
		//if ( (x_choice == 1 && mt1 == 0x3) || (x_choice == 2 && (command == 0xEE || command == 0xEF)) ){ //LCN CALLS	
        //using mt1 values 0x2 and 0x1 produce lots of hits on higher LCN channels, not sure if this is a logical data call, or bogus.
        //going to see if high LCN values still occur with BCH enabled, if so, and not MT-1 0x3, then possible issues on CC or something.
        //most all bad decodes occur from GR sadly, really need to tweak GNURadio GR files, BCH tosses lots of those frames out

		  //only increment LCN channel list on 0x3 for testing, revert later when 0x2 and 0x1 are figured out properly
          if ((x_choice == 1 && lcn > lcn_tally && mt1 == 0x3) || (lcn > lcn_tally && x_choice == 2)) {
            lcn_tally = lcn;
          } 
          voice_to = 0; //0-active
          deny_flag = 0; //reset trip on deny_flag
          allow = 0; //reset trip on alow flag during universal denial
          groupx = (fr_1t & 0xFFFF000) >> 12;
          if (x_choice == 2) {
            groupx = afs;
          }
          senderx = (fr_4t & 0xFFFFF000) >> 12;
          group_matrix[lcn][0] = " "; //initialize with a space, otherwise printw is NULL if no value present in csv file
          group_matrix[lcn][1] = " ";
          csvGroupImport();

          call_matrix[lcn][0] = time(NULL);
          call_matrix[lcn][1] = groupx;
          call_matrix[lcn][2] = senderx;

          if (x_choice == 1) {
            call_matrix[lcn][3] = mt1;
          }
          if (x_choice == 2) {
            call_matrix[lcn][3] = status;
          }

          if (tsenderx != senderx && x_choice == 1 && site_id > 0 && L == 1) 
          {
            FILE * pFile;
            pFile = fopen("voice.log", "a");
            fprintf(pFile, "%s %s \tSITE %3lld \tLCN %2d \tTG %5lld \tRID %lld \n", getDate(), getTime(), site_id, lcn, groupx, senderx);
            //fprintf(pFile, "%s %s \tSITE %3lld \tLCN %2d \tTG %5lld \tRID %lld [0x%2llX][0x%1llX] \n", getDate(), getTime(), site_id, lcn, groupx, senderx, mt1, mt2);
            fclose(pFile);
            tsenderx = senderx;
          }
            
          //fixed splat in afs.log on startup by seperating getDate and getTime from the rest
          if (tafs != afs && x_choice == 2 && site_id > 0 && L == 1) {
            FILE * pFile;
            pFile = fopen("afs.log", "a");
            fprintf(pFile, "%s %s", getDate(), getTime() );
            if (status == 0xF) {
              fprintf(pFile, "\tSITE %3lld \tLCN %2d \tAFS[%4lld][%d-%d-%d]\tDigital\n", site_id, lcn, afs, agency, fleet, subfleet);
            }
            if (status == 0xE) {
              fprintf(pFile, "\tSITE %3lld \tLCN %2d \tAFS[%4lld][%d-%d-%d]\tAnalog\n", site_id, lcn, afs, agency, fleet, subfleet);
            }
            fclose(pFile);
            tafs = afs;
          }

          if (lcn == current_lcn) //lcn==current_lcn
          {
            last_voice_time = time(NULL);
          }
          print_timeri = 20;

          mode_a = "DE"; //Digital Encrypted from csv, blocking
          mode_b = mode;
          modecompare = strcmp(mode_a, mode_b);
          if (modecompare == 0) {
            deny_flag = 1;
            current_lcn = lcn; //not sure if should use this or not, will test <- initial tests seem good, continue to test
          }
          mode_a = "B"; //Blocked Group from csv
          modecompare = strcmp(mode_a, mode_b);
          if (modecompare == 0) {
            deny_flag = 1;
            current_lcn = lcn; //not sure if should use this or not, will test <- initial tests seem good, continue to test
          }
          if (udeny == 0 && deny_flag == 0 && lcn != current_lcn && voice_to == 0) //tune to LCN if lcn didn't change and voice_to is active
          {
            tune(LCN_list[lcn - 1]);
            current_lcn = lcn;
            squelchSet(0); //unmute
            //voice_to=0; // voice_to = 0 is for active
            hanguptime = time(NULL); // trying this really quick
          }

          mode_a = "A"; //Allow Group from csv
          modecompare = strcmp(mode_a, mode_b);
          if (modecompare == 0) {
            allow = 1;
            current_lcn = lcn; //not sure if should use this or not, will test <- initial tests seem good, continue to test
          }
          if (udeny == 1 && allow == 1) //tune to LCN if if univeral denial active and allowed group
          {
            tune(LCN_list[lcn - 1]);
            current_lcn = lcn;
            squelchSet(0); //unmute
            hanguptime = time(NULL); // trying this really quick
            //voice_to=0; // voice_to = 0 is for active
          }
        }//this once closes vcmd 
      } //this one closes big overarcing fr_1 == fr_3 && fr_4 == fr_6
       //-------------------------------------------------
      //singular printw area
      last_sync_time = time(NULL); //set timestamp, does this still go here?
      print_timeri = print_timeri - 1; //primitive timer for printing out IDLE status updates
      erase();
      attron(COLOR_PAIR(1));
      for (short int i = 0; i < 13; i++) {
        printw("%s \n", FM_banner[i]);
      }
      
      attroff(COLOR_PAIR(1));
      
      printw("--Site Info----------------------------------------------------------------\n"); //making a fence 
      printw("| %s %s ", getDate(), getTime()); //keep date and time seperate, or strange things happen sometimes
      printw("SNR [%2.0f] \n", (gbr * 100) );
      printw("| Site ID [%3lld][%2llX] Location: %s\n", site_id, site_id, location_name);

      if (x_choice == 1) { 
        printw("| Peer Sites ");
        for (short int i = 0; i < 12; i++) {
          if (peer_list[i] > 0) {
            printw("[%lld]", peer_list[i]);
          }
        }
        printw("\n");
      }
      printw("---------------------------------------------------------------------------\n"); //making a fence 
      if (x_choice == 1 && S == 1) {
		attron(COLOR_PAIR(4));
		printw("--Site Extra---------------------------------------------------------------\n"); //making a fence 
        printw("| Peer Site [%lld] on Control LCN [%lld]\n", peer, peer_lcn);
        attroff(COLOR_PAIR(4));
      }
      if (x_choice == 2 && S == 1) { //changing to S == 1
		attron(COLOR_PAIR(4));  
		printw("--Site Extra---------------------------------------------------------------\n"); //making a fence
        printw("| Status Bits = ", status);
        for (unsigned short int i = 0; i < 4; i++) {
          signed short int buffer = (status >> 3 - i) & 0x1;
          printw("[%1d] ", buffer);
        }
        printw("\n");
        attroff(COLOR_PAIR(4));
      }
      if (x_choice == 1 && S == 1) { //changing to S == 1
		attron(COLOR_PAIR(4));  
        printw("| MT-1 ");
        for (unsigned short int i = 0; i < 5; i++) {
          signed short int buffer = (mt1 >> 4 - i) & 0x1;
          printw("[%1d] ", buffer);
        }
        printw("\n");
        printw("| MT-2 ");
        for (unsigned short int i = 0; i < 4; i++) {
          signed short int buffer = (mt2 >> 3 - i) & 0x1;
          printw("[%1d] ", buffer);
        }
        printw("\n");
        attroff(COLOR_PAIR(4));
      }
      if (S == 1) { //changing to S == 1
		attron(COLOR_PAIR(4));
		//printw("| FR-1 [%10llX] \n", fr_1);
        //printw("| FR-4 [%10llX] \n", fr_4);
        printw("| FR-1 [%10llX]\n", fr_1t);
        printw("| FR-4 [%10llX]\n", fr_4t);
        //printw("| SNR  [%2.2f]Percent - AFC [%d]Hz  - Frames [%8.0f] \n", (gbr * 100), AFC, (good+bad) ); //this line is ugly
        printw("---------------------------------------------------------------------------\n"); //making a fence 
        attroff(COLOR_PAIR(4));
	  }
	  printw("--Call Info----------------------------------------------------------------\n"); //making a fence  
      for (short int i = 0; i < lcn_tally; i++) {
        printw("| LCN [%2d] ", lcn_tally - (lcn_tally - 1) + i);
        printw("[%lld]Hz ", LCN_list[i]);
        if (CC_LCN == (i + 1)) {
          attron(COLOR_PAIR(1));
          printw("Control Channel");
          attroff(COLOR_PAIR(1));
        }

        if (x_choice == 1 && (time(NULL) - call_matrix[i + 1][0] < 2) && call_matrix[i + 1][1] > 0) {
          attron(COLOR_PAIR(3));
          printw("RID [%lld] TG [%lld] [%s] [%s] ", call_matrix[i + 1][2], call_matrix[i + 1][1], group_matrix[i + 1][0], group_matrix[i + 1][1]); 
          if (call_matrix[i + 1][3] == 0x3) {
            printw("Digital");
          }
          if (call_matrix[i + 1][3] == 0x2) {
            printw("Data");
          }
          if (call_matrix[i + 1][3] == 0x1) {
            printw("TDMA");
          }
          attroff(COLOR_PAIR(3));
        }
        if (x_choice == 1 && ((time(NULL) - call_matrix[i + 1][0]) < 5) && ((time(NULL) - call_matrix[i + 1][0]) >= 2) && call_matrix[i + 1][1] > 0) {
          attron(COLOR_PAIR(2));
          printw("RID [%lld] TG [%lld] [%s] [%s] ", call_matrix[i + 1][2], call_matrix[i + 1][1], group_matrix[i + 1][0], group_matrix[i + 1][1]); //group_matrix testing
          if (call_matrix[i + 1][3] == 0x3) {
            printw("Digital");
          }
          if (call_matrix[i + 1][3] == 0x2) {
            printw("Data");
          }
          if (call_matrix[i + 1][3] == 0x1) {
            printw("TDMA");
          }
          attroff(COLOR_PAIR(2));
        }
        if (x_choice == 2 && (time(NULL) - call_matrix[i + 1][0] < 2) && call_matrix[i + 1][1] > 0) {
          attron(COLOR_PAIR(3));
          printw("AFS [%lld] [%d-%d-%d] [%s] [%s] ", call_matrix[i + 1][1], ((call_matrix[i + 1][1] & a_mask) >> (11 - a_len)), ((call_matrix[i + 1][1] & f_mask) >> s_len), (call_matrix[i + 1][1] & s_mask), group_matrix[i + 1][0], group_matrix[i + 1][1]);
          if (call_matrix[i + 1][3] == 0xE) {
            printw("Analog");
          }
          if (call_matrix[i + 1][3] == 0xF) {
            printw("Digital");
          }
          attroff(COLOR_PAIR(3));
        }
        if (x_choice == 2 && ((time(NULL) - call_matrix[i + 1][0]) < 5) && ((time(NULL) - call_matrix[i + 1][0]) >= 2) && call_matrix[i + 1][1] > 0) {
          attron(COLOR_PAIR(2));
          printw("AFS [%lld] [%d-%d-%d] [%s] [%s] ", call_matrix[i + 1][1], ((call_matrix[i + 1][1] & a_mask) >> (11 - a_len)), ((call_matrix[i + 1][1] & f_mask) >> s_len), (call_matrix[i + 1][1] & s_mask), group_matrix[i + 1][0], group_matrix[i + 1][1]);
          if (call_matrix[i + 1][3] == 0xE) {
            printw("Analog");
          }
          if (call_matrix[i + 1][3] == 0xF) {
            printw("Digital");
          }
          attroff(COLOR_PAIR(2));
         
        }
        //leaving this here for reference, its used in the AFS bits printw instead of needlessly expanding the array to cram it in
        //agency =  ((call_matrix[i+1][1] & a_mask) >> (11 - a_len)); 
        //fleet =    ((call_matrix[i+1][1] & f_mask) >> s_len); 
        //subfleet =  (call_matrix[i+1][1] & s_mask);
        printw("\n");
      }
      printw("---------------------------------------------------------------------------\n"); //making a fence
      if (x_choice == 1 && C == 1) { //Print Call_Matrix "History" for EA
		attron(COLOR_PAIR(4));
		printw("--Call Matrix--------------------------------------------------------------\n"); //making a fence  
        for (short int i = 0; i < 32; i++) {
          if (call_matrix[i][0] > 0) {
            printw("| LCN [%2lld] RID [%6lld] TG [%5lld] [%17s] Seconds Ago: %5llds|\n", i, call_matrix[i][2], call_matrix[i][1], group_matrix[i][0], (time(NULL) - call_matrix[i][0]) );
          }
        }
        printw("---------------------------------------------------------------------------\n"); //making a fence  
        attroff(COLOR_PAIR(4));
      }
      if (x_choice == 2 && C == 1) { //Print Call_Matrix "History" for AFS
		attron(COLOR_PAIR(4));
		printw("--Call Matrix--------------------------------------------------------------\n"); //making a fence  
        for (short int i = 0; i < 32; i++) {
          if (call_matrix[i][0] > 0) {
            printw("| LCN [%2lld] AFS [%4lld] [%2d-%2d-%2d] [%19s] Seconds Ago: %5llds|\n", i, call_matrix[i][1], ((call_matrix[i][1] & a_mask) >> (11 - a_len)), ((call_matrix[i][1] & f_mask) >> s_len), (call_matrix[i][1] & s_mask), group_matrix[i][0], (time(NULL) - call_matrix[i][0]) );
          }
        }
        printw("---------------------------------------------------------------------------\n"); //making a fence  
        attroff(COLOR_PAIR(4));
      }
      if (x_choice == 1 && P == 1) { //Print Pretty Patch Array
		attron(COLOR_PAIR(4));
		printw("--Patch Groups-------------------------------------------------------------\n"); //making a fence  
        for (short int i = 0; i < 48;) {
          if (patch_array[i][0] > 0) {
            printw("| Patch Group #%2d [%5lld] to [%5lld] | ", i + 1, patch_array[i][1], patch_array[i][0]);
            printw("Patch Group #%2d [%5lld] to [%5lld] |\n", i + 2, patch_array[i+1][1], patch_array[i+1][0]);
          }
          i = i + 2;
        }
        printw("---------------------------------------------------------------------------\n"); //making a fence  
        attroff(COLOR_PAIR(4));
      }
      refresh();
    } //this one closes sync frame
     //else {} //no idea why I have this one, not sure if I need it or not
  } //this one terminates while loop
  endwin(); //terminate NCURSES screen
  return 0;
} //terminate main
