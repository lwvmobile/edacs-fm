/*-------------------------------------------------------------------------------
 * EDACS-FM 
 * A program for decoding edacs/edacs extended addressing with esk
 * 
 * ASCII art generated by:
 * https://fsymbols.com/generators/carty/
 * 
 * Jail Ascii Art by:
 * https://ascii.co.uk/art/jail
 * 
 * Portions of this software originally from: 
 * https://github.com/sp5wwp/ledacs     
 * XTAL Labs
 * 30 IV 2016
 * Many thanks to SP5WWP for permission to use and modify this software
 * 
 * LWVMOBILE  
 * 2021-11 Version 1.0 EDACS-FM Florida Man Edition
 *-----------------------------------------------------------------------------*/
#define _GNU_SOURCE

#include <stdio.h>

#include <unistd.h>

#include <limits.h>

#include <string.h>

#include <stdlib.h>

#include <arpa/inet.h>

#include <sys/types.h>

#include <sys/socket.h>

#include <netinet/in.h>

#include <fcntl.h>

#include <errno.h>

#include <time.h>

#include <ncurses.h>

#include <stdio_ext.h> //new start

#include <math.h>

#include <netdb.h>

#include <sys/stat.h>

#include <pwd.h>

#include <termios.h>

#include <getopt.h>

#include <ctype.h>

#include <stdbool.h>

#include <locale.h>  //end new
//
#define NB_ENABLE true
#define NB_DISABLE false
//
#define BSIZE 999
#define UDP_BUFLEN 5 //maximum UDP buffer length
#define SRV_IP "127.0.0.1" //IP
#define UDP_PORT 6020 //UDP port

#define SAMP_NUM (48 + 6 * 40) * 2 * 3 //EDACS96 288-bit cycle
#define SYNC_FRAME 0x555557125555 << (64 - 48) //EDACS96 synchronization frame (12*4=48bit)
#define SYNC_MASK 0xFFFFFFFFFFFF << (64 - 48) //EDACS96 synchronization frame mask

#define CMD_SHIFT 8 //data location in sr_0
#define CMD_MASK 0xFF << CMD_SHIFT //DON'T TOUCH

#define LCN_SHIFT 3 //for other SR-s these values are hardcoded below
#define LCN_MASK 0xF8
#define STATUS_MASK 0x07

#define SYNC_TIMEOUT 3 //maximum time between sync frames in seconds
#define VOICE_TIMEOUT 1 //maximum time of unsquelched audio after last voice channel assignment command in seconds
//New CC Commands added
#define DATA_CMD 0xFA //0xA0    
#define DATA_CMDX 0xFB //0xA1
#define ID_CMD 0xFD //0xFD
#define PATCH_CMD 0xFE //0xEC
#define PEER_CMD 0xF8
#define VOICE_CMDX 0x18 //0x18 is VOICE_CMDX (B8 xor A0)
#define IDLE_CMD 0xFC //CC commands
#define VOICE_CMD 0xEE //

#define MAX_LCN_NUM 32 //maximum number of Logical Channels
#define PEER_MAX 6

unsigned char samples[SAMP_NUM]; //8-bit samples from rtl_fm (or rtl_udp)
signed short int raw_stream[SAMP_NUM / 2]; //16-bit signed int samples

signed int AFC = 2400; //Auto Frequency Control -> DC offset
signed int min = SHRT_MAX, max = SHRT_MIN; //min and max sample values
signed short int avg_arr[SAMP_NUM / 2 / 3]; //array containing 16-bit samples
unsigned int avg_cnt = 0; //avg array index variable

unsigned long long sr_0 = 0; //64-bit shift registers for pushing decoded binary data
unsigned long long sr_1 = 0; //288/64=4.5
unsigned long long sr_2 = 0; //
unsigned long long sr_3 = 0; //
unsigned long long sr_4 = 0; //

unsigned long long fr_6 = 0; //40-bit shift registers for pushing decoded binary data
unsigned long long fr_1 = 0xFFFFFFFFFF; //each is a 40 bit message that repeats 3 times
unsigned long long fr_2 = 0; //two messages per frame
unsigned long long fr_3 = 0; //
unsigned long long fr_4 = 0xFFFFFFFFFF; //These are the human readable versions for debugging etc
unsigned long long fr_5 = 0;

unsigned short a_len = 4; //AFS allocation type
unsigned short f_len = 4; //bit lengths
unsigned short s_len = 3; //
unsigned short a_mask = 0x0; //and corresponding masks, set to 0 by default or they will accumulate when shifting
unsigned short f_mask = 0x0; //
unsigned short s_mask = 0x0; //

unsigned short x_mask = 0xA0;
unsigned short x_choice = 1;
//
unsigned long long afs = 0; //AFS 11-bit info
unsigned long long int patch_site = 0;
unsigned long long int site_id = 0;
unsigned long long int start_site_id = 0;

unsigned long long int tempsite_id = 999;
unsigned long long int tgroupx = 999;
signed long long int senderx = 0;
unsigned long long int groupx = 0;
signed long long int sourcep = 0;
signed long long int targetp = 0;
signed long long kicked = 0;
signed long long int tsenderx = 0;
unsigned long long tafs = 999;
unsigned long long sender = 0;
unsigned long long tsender = 0;

char * mode_a;
char * mode_b;
int modecompare;
char * mode;
char * groupx_name;
char * site_name;
char * location_name;
unsigned char mt1 = 0x1F;
unsigned char mt2 = 0xF;
unsigned char mta = 0;
unsigned char mtb = 0;
unsigned char mtd1 = 0;
unsigned char mtd2 = 0;
int adjust = 0; //highly temperamental, don't use for now
int cyclecc = 0;
signed int ppm = 0;

signed int lshifter = 0; //LCN bit shifter
unsigned int vcmd = 0x00; //voice command variable set by argument
unsigned int idcmd = 0x00;
unsigned char xcommand = 0; //XOR of command variable
unsigned char command = 0; //read from control channel
unsigned char xlcn = 0;
unsigned char lcn = 0;
unsigned char lcn_tally = 0;
unsigned char lcn_tick = 0;
unsigned char xstatus = 0; //
unsigned char status = 0; //
unsigned char agency = 0, fleet = 0, subfleet = 0; //
//
unsigned short lafs = 0x000;
char * sitecsv;
char * groupcsv;
int rfgain = 0;

unsigned char CRC = 0;
int active = 0;
unsigned long long int last_sync_time = 0; //last received sync timestamp
unsigned long long int last_voice_time = 0; //last received voice channel assignment timestamp

unsigned char current_lcn = 0; //current LCN
unsigned long long int LCN_list[MAX_LCN_NUM]; //LCN list
unsigned char lcn_num = 0; //number of logical channels
unsigned char cc = 1;

unsigned char allow_num = 0;
unsigned int allow_total = 0;

unsigned char deny_num = 0;
unsigned int deny_total = 0;
signed int deny_flag = 0;
short int udeny = 0;
short int allow = 0;
unsigned long long ID_FR1 = 0; //making this to investigate 0xFC IDLE command, remove later on
unsigned long long ID_FR4 = 0; //making this to investigate 0xFC IDLE command, remove later on
unsigned long long int CC_LCN = 0;
unsigned long long int hanguptime = 0;

char * FM_banner[14] = {

"||   ||     ||   || ███████╗██████╗░░█████╗░░█████╗░░██████╗                   ",
"||   ||, , ,||   || ██╔════╝██╔══██╗██╔══██╗██╔══██╗██╔════╝                   ",
"||  (||/|/(|||/  || █████╗░░██║░░██║███████║██║░░╚═╝╚█████╗░                   ",
"||  ||| _'_`|||  || ██╔══╝░░██║░░██║██╔══██║██║░░██╗░╚═══██╗                   ",
"||   || o o ||   || ███████╗██████╔╝██║░░██║╚█████╔╝██████╔╝                   ",
"||  (||  - `||)  || ╚══════╝╚═════╝░╚═╝░░╚═╝░╚════╝░╚═════╝░                   ",
"||   ||  =  ||   || ███████╗███╗░░░███╗  Florida Man Edition                   ",
"||   || (_) ||   || ██╔════╝████╗░████║  Thanks to:                            ",
"||___||) , (||___|| █████╗░░██╔████╔██║    sp5wwp                              ",
"||---||- _ -||---|| ██╔══╝░░██║╚██╔╝██║    EricCottrell                        ",
"||--_||_____||_--|| ██║░░░░░██║░╚═╝░██║    JSTARS03                            ",
"||)-| S243-F3 |-(|| ╚═╝░░░░░╚═╝░░░░░╚═╝    blantonl                            ",
"|| | ||     |||  ||     ...and the radioreference.com forums                   "                                        
};

signed int peer_counter = 0;
signed long long int peer_list[6] = {
  0,
  0,
  0,
  0,
  0,
  0
};
signed long long int peer = 0;

signed int debug = 0; //debug value for printing out status and data on different command codes, etc
unsigned short d_choice = 0; //verbosity levels so users can see debug information etc                                   

signed short int print_timeri = 10;
char inp = 'x';

int handle; //for UDP
unsigned short port = UDP_PORT; //
char data[UDP_BUFLEN] = {
  0
}; //
struct sockaddr_in address; //

//--------------------------------------------
typedef struct key_value {
  char siteN[20];
  char location[20];
  char lcn0N[50];
  char lcn1N[50];
  char lcn2N[50];
  char lcn3N[50];
  char lcn4N[50];
  char lcn5N[50];
  char lcn6N[50];
  char lcn7N[50];
  char lcn8N[50];
  char lcn9N[50]; //need to expand to 31
  char lcn10N[50];
  char lcn11N[50];
  char lcn12N[50];
  char lcn13N[50];
  char lcn14N[50];
  char lcn15N[50];
  char lcn16N[50];
  char lcn17N[50];
  char lcn18N[50];
  char lcn19N[50];
  char lcn20N[50];
  char lcn21N[50];
  char lcn22N[50];
  char lcn23N[50];
  char lcn24N[50];
  char lcn25N[50];
  char lcn26N[50];
  char lcn27N[50];
  char lcn28N[50];
  char lcn29N[50];
  char lcn30N[50];
  char lcn31N[50];

}
dict;

void loadLCN(int tsite_id, dict site_array[]) //load LCN frequencies from csv importer/struct
{
  LCN_list[0] = atoi(site_array[tsite_id].lcn0N);
  LCN_list[1] = atoi(site_array[tsite_id].lcn1N);
  LCN_list[2] = atoi(site_array[tsite_id].lcn2N);
  LCN_list[3] = atoi(site_array[tsite_id].lcn3N);
  LCN_list[4] = atoi(site_array[tsite_id].lcn4N);
  LCN_list[5] = atoi(site_array[tsite_id].lcn5N);
  LCN_list[6] = atoi(site_array[tsite_id].lcn6N);
  LCN_list[7] = atoi(site_array[tsite_id].lcn7N);
  LCN_list[8] = atoi(site_array[tsite_id].lcn8N);
  LCN_list[9] = atoi(site_array[tsite_id].lcn9N);
  LCN_list[10] = atoi(site_array[tsite_id].lcn10N);
  LCN_list[11] = atoi(site_array[tsite_id].lcn11N);
  LCN_list[12] = atoi(site_array[tsite_id].lcn12N);
  LCN_list[13] = atoi(site_array[tsite_id].lcn13N);
  LCN_list[14] = atoi(site_array[tsite_id].lcn14N);
  LCN_list[15] = atoi(site_array[tsite_id].lcn15N);
  LCN_list[16] = atoi(site_array[tsite_id].lcn16N);
  LCN_list[17] = atoi(site_array[tsite_id].lcn17N);
  LCN_list[18] = atoi(site_array[tsite_id].lcn18N);
  LCN_list[19] = atoi(site_array[tsite_id].lcn19N);
  LCN_list[20] = atoi(site_array[tsite_id].lcn20N);
  LCN_list[21] = atoi(site_array[tsite_id].lcn21N);
  LCN_list[22] = atoi(site_array[tsite_id].lcn22N);
  LCN_list[23] = atoi(site_array[tsite_id].lcn23N);
  LCN_list[24] = atoi(site_array[tsite_id].lcn24N);
  LCN_list[25] = atoi(site_array[tsite_id].lcn25N);
  LCN_list[26] = atoi(site_array[tsite_id].lcn26N);
  LCN_list[27] = atoi(site_array[tsite_id].lcn27N);
  LCN_list[28] = atoi(site_array[tsite_id].lcn28N);
  LCN_list[29] = atoi(site_array[tsite_id].lcn29N);
  LCN_list[30] = atoi(site_array[tsite_id].lcn30N);
  LCN_list[31] = atoi(site_array[tsite_id].lcn31N); 
  site_name = site_array[tsite_id].siteN;
  location_name = site_array[tsite_id].location;
}

int csvImport() {
  char filename[] = "site.csv";
  strcpy(filename, sitecsv);
  char buffer[BSIZE];
  FILE * fp;
  fp = fopen(filename, "r");
  if (fp == NULL) {
    printf("Unable to open file '%s'\n", filename);
    exit(1);
  }
  int row_count = 0;
  int field_count = 0;
  dict site_array[9999]; //array to struct to store values
  int tsite_id = site_id;
  //int i = 0;
  while (fgets(buffer, BSIZE, fp)) {
    field_count = 0;
    row_count++;
    if (row_count == 1)
      continue; //don't want labels
    char * field = strtok(buffer, ","); //seperate by comma
    int i = atoi(field); //field is seeing site id, make dict based on i value for site id, then cross reference later on for LCN
    while (field) {
      if (field_count == 0)
        strcpy(site_array[i].siteN, field);

      if (field_count == 1)
        strcpy(site_array[i].location, field);

      if (field_count == 2)
        strcpy(site_array[i].lcn0N, field);

      if (field_count == 3)
        strcpy(site_array[i].lcn1N, field);

      if (field_count == 4)
        strcpy(site_array[i].lcn2N, field);

      if (field_count == 5)
        strcpy(site_array[i].lcn3N, field);

      if (field_count == 6)
        strcpy(site_array[i].lcn4N, field);

      if (field_count == 7)
        strcpy(site_array[i].lcn5N, field);

      if (field_count == 8)
        strcpy(site_array[i].lcn6N, field);

      if (field_count == 9)
        strcpy(site_array[i].lcn7N, field);

      if (field_count == 10)
        strcpy(site_array[i].lcn8N, field);

      if (field_count == 11)
        strcpy(site_array[i].lcn9N, field);
      
      if (field_count == 12)
        strcpy(site_array[i].lcn10N, field);
      
      if (field_count == 13)
        strcpy(site_array[i].lcn11N, field);
      
      if (field_count == 14)
        strcpy(site_array[i].lcn12N, field);
      
      if (field_count == 15)
        strcpy(site_array[i].lcn13N, field);
      
      if (field_count == 16)
        strcpy(site_array[i].lcn14N, field);
      
      if (field_count == 17)
        strcpy(site_array[i].lcn15N, field);
      
      if (field_count == 18)
        strcpy(site_array[i].lcn16N, field);
      
      if (field_count == 19)
        strcpy(site_array[i].lcn17N, field);
      
      if (field_count == 20)
        strcpy(site_array[i].lcn18N, field);
      
      if (field_count == 21)
        strcpy(site_array[i].lcn19N, field);
      
      if (field_count == 22)
        strcpy(site_array[i].lcn20N, field);
      
      if (field_count == 23)
        strcpy(site_array[i].lcn21N, field);
      
      if (field_count == 24)
        strcpy(site_array[i].lcn22N, field);
      
      if (field_count == 25)
        strcpy(site_array[i].lcn23N, field);
      
      if (field_count == 26)
        strcpy(site_array[i].lcn24N, field);
      
      if (field_count == 27)
        strcpy(site_array[i].lcn25N, field);
      
      if (field_count == 28)
        strcpy(site_array[i].lcn26N, field);
      
      if (field_count == 29)
        strcpy(site_array[i].lcn27N, field);
      
      if (field_count == 30)
        strcpy(site_array[i].lcn28N, field);
      
      if (field_count == 31)
        strcpy(site_array[i].lcn29N, field);
      
      if (field_count == 32)
        strcpy(site_array[i].lcn30N, field);
      
      if (field_count == 33)
        strcpy(site_array[i].lcn31N, field);

      field = strtok(NULL, ",");
      field_count++;
    }
  }
  fclose(fp);
  loadLCN(tsite_id, site_array);

  return 0;
}
typedef struct key_v {

  signed long long int groupNumber;
  char groupMode[8];
  char groupName[50];

}
groupinfo;

//WIP patch array, may lead to using active voice channel array if I can get it to work
/*
typedef struct patch_v {
    
    signed long long int targetd[8];
    signed long long int sourced[8];
}
parray;

signed long long int makePatchArray(signed long long int ttargetd, parray[] ) {
    parray patcharray[10000];
    patcharray[ttargetd].targetd = targetp;
    patcharray[ttargetd].sourced = sourcep;
}
// WIP 
*/
void loadGroupInfo(signed long long int tgroup_id, groupinfo group_array[]) {
  groupx_name = group_array[tgroup_id].groupName;
  mode = group_array[tgroup_id].groupMode;

}

signed long long int csvGroupImport() {
  char filename[] = "group.csv";
  strcpy(filename, groupcsv);
  char buffer[BSIZE];
  FILE * fp;
  fp = fopen(filename, "r");
  if (fp == NULL) {
    printf("Unable to open file '%s'\n", filename);
    exit(1);
  }
  long long int row_count = 0;
  int field_count = 0;
  groupinfo group_array[67000]; //array to struct to store values
  signed long long int tgroup_id2 = groupx;

  while (fgets(buffer, BSIZE, fp))
  {
    field_count = 0;
    row_count++;
    if (row_count == 1)
      continue; //don't want labels
    char * field = strtok(buffer, ","); //seperate by comma
    signed long long int i = atoi(field); //field is seeing site id, make dict based on i value for site id, then cross reference later on for LCN
    while (field) {
      if (field_count == 0)
        group_array[i].groupNumber = atoi(field);

      if (field_count == 1)
        strcpy(group_array[i].groupMode, field);

      if (field_count == 2)
        strcpy(group_array[i].groupName, field);

      field = strtok(NULL, ",");
      field_count++;
    }
  }
  fclose(fp);
  loadGroupInfo(tgroup_id2, group_array);
  return 0;
}
int init_udp() //UDP init
{
  handle = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

  if (handle <= 0) {
    printf("Failed to create socket\n");
    return 1;
  }

  printf("Sockets successfully initialized\n");

  memset((char * ) & address, 0, sizeof(address));

  address.sin_family = AF_INET;
  address.sin_addr.s_addr = inet_addr(SRV_IP); //address of host
  address.sin_port = htons(port);

  return 0;
}

char * getTime(void) //get pretty hh:mm:ss timestamp
{
  time_t t = time(NULL);

  char * curr;
  char * stamp = asctime(localtime( & t));

  curr = strtok(stamp, " ");
  curr = strtok(NULL, " ");
  curr = strtok(NULL, " ");
  curr = strtok(NULL, " ");

  return curr;
}

char * logTime(void) {
  struct tm * ptr;
  char * stamp2;
  time_t t;
  t = time(NULL);
  ptr = localtime( & t);
  stamp2 = asctime(ptr);
  return stamp2;
}
char * getDate(void) {
  char datename[32];
  char * curr2;
  struct tm * to;
  time_t t;
  t = time(NULL);
  to = localtime( & t);
  strftime(datename, sizeof(datename), "%Y-%m-%d", to);
  curr2 = strtok(datename, " ");
  return curr2;
}
//--------------------------------------------
void tune(unsigned long long int freq) //tuning to LCN freq
{
  data[0] = 0;
  data[1] = freq & 0xFF;
  data[2] = (freq >> 8) & 0xFF;
  data[3] = (freq >> 16) & 0xFF;
  data[4] = (freq >> 24) & 0xFF;

  sendto(handle, data, UDP_BUFLEN, 0, (const struct sockaddr * ) & address, sizeof(struct sockaddr_in));
}

void tuneCC(unsigned long long int ccfreq) //tuning to CC freq, only works with PyEDACS tuner, not rtl_udp
{
  data[0] = 9;
  data[1] = ccfreq & 0xFF;
  data[2] = (ccfreq >> 8) & 0xFF;
  data[3] = (ccfreq >> 16) & 0xFF;
  data[4] = (ccfreq >> 24) & 0xFF;

  sendto(handle, data, UDP_BUFLEN, 0, (const struct sockaddr * ) & address, sizeof(struct sockaddr_in));
}

void ppmAdjust(unsigned long long int ccppm) //adjustments to CC PPM, only works with PyEDACS tuner, not rtl_fm/udp
{
  data[0] = 7;
  data[1] = ccppm & 0xFF;
  data[2] = (ccppm >> 8) & 0xFF;
  data[3] = (ccppm >> 16) & 0xFF;
  data[4] = (ccppm >> 24) & 0xFF;

  sendto(handle, data, UDP_BUFLEN, 0, (const struct sockaddr * ) & address, sizeof(struct sockaddr_in));
}

void squelchSet(unsigned long long int sq) //squelch
{
  data[0] = 2;
  data[1] = sq & 0xFF;
  data[2] = (sq >> 8) & 0xFF;
  data[3] = (sq >> 16) & 0xFF;
  data[4] = (sq >> 24) & 0xFF;

  sendto(handle, data, UDP_BUFLEN, 0, (const struct sockaddr * ) & address, sizeof(struct sockaddr_in));
}

void gainSet(int gain) //adjustments to RF Gain in PyEDACS tuner, may also function in rtl_udp
{
  data[0] = 3; // 3 on rtl_udp is for new_gain, so maybe works with both, unsure yet, 8 is AGC mode
  data[1] = gain & 0xFF;
  data[2] = (gain >> 8) & 0xFF;
  data[3] = (gain >> 16) & 0xFF;
  data[4] = (gain >> 24) & 0xFF;

  sendto(handle, data, UDP_BUFLEN, 0, (const struct sockaddr * ) & address, sizeof(struct sockaddr_in));
}

void ENT() //Print a swanky ascii art banner
{

  for (short int i = 0; i < 13; i++) {
    printf("%s \n", FM_banner[i]);
  }
}

void print_usage(char * name) {

  printf("Usage:\n");
  exit(EXIT_FAILURE);
}
bool ParseInputOptions(int argc, char ** argv) {
  int c;

  while (1) {
    static struct option long_options[] = {
      /* These options set a flag. */
      //{"verbose", no_argument,       &opt_verbose, 1},
      /* These options don’t set a flag.
         We distinguish them by their indices. */
      {"case t",                no_argument,0,'t'},
      {"Universal Denial",      no_argument,0,'d'},
      {"verbose",               no_argument,0,'v'},
      {"legacy",                no_argument,0,'l'},
      {"esk",                   no_argument,0,'e'},
      {"esk-ea",                no_argument,0,'x'},
      {"afs A bit",             required_argument,0,'a'},
      {"afs F bit",             required_argument,0,'f'},
      {"siteinfo",              required_argument,0,'s'},
      {"sitenumber",            required_argument,0,'c'},
      {"group",                 required_argument,0,'g'},
      {"RF gain",               required_argument,0,'r'},
      {"ppm-auto-adjustments",  no_argument,0,'p'},
      {0,0,0,0}
    };
    /* getopt_long stores the option index here. */
    int option_index = 0;

    c = getopt_long(argc, argv, "t d v l e x a:f:s:c:g:r:p",
      long_options, & option_index);

    // warning: I don't know why but required argument are not so "required" <--need to use : after required arguments, no colon for optional ones
    //          if a following option is encountered getopt_long returns this option as the argument in optarg 
    //          instead of error, but if there is only one option with a missing arg then it returns an error.
    //          

    /* Detect the end of the options. */
    if (c == -1)
      break;

    switch (c) {
    case 0:
      /* If this option set a flag, do nothing else now. */
      if (long_options[option_index].flag != 0)
        break;
      printf("option %s", long_options[option_index].name);
      if (optarg)
        printf(" with arg %s", optarg);
      printf("\n");
      break;
    case 'd':
      udeny = 1;
      printf("Universal Denial Mode Set - Only groups with mode [A] will be granted voice channel\n");
      break;
    case 'v':
      debug = 3;
      printf("Verbosity Mode Enabled - Debug set to 3 \n");
      break;
    case 'x':
      printf("ESK-EA Mode Enabled \n");
      x_mask = 0xA0; //XOR for ESK
      idcmd = 0xFD;
      vcmd = 0x18;
      lshifter = 2;
      x_choice = 1;
      break;
    case 'e':
      printf("ESK Mode Enabled \n");
      x_mask = 0xA0; //XOR for ESK
      idcmd = 0xFD;
      vcmd = 0xEE;
      lshifter = 2;
      x_choice = 2;
      break;  
    case 'l':
      printf("EDACS Standard Mode Enabled \n");
      x_mask = 0x0; //no XOR for legacy
      vcmd = 0xEE;
      idcmd = 0xFD;
      lshifter = 2;
      x_choice = 2;
      break;
    case 'a':
      a_len = atol(optarg); 
      printf("Agency bit setting = [%d] bits\n", a_len);
      break;
    case 'f':
      f_len = atol(optarg); 
      printf("Fleet bit setting = [%d] bits\n", f_len);
      break;  
    case 's':
      if (optarg[0] == '-') {
        printf("Error: -%c: option requires an argument\n", c);
        print_usage(argv[0]);
      }
      sitecsv = optarg;
      printf("Site CSV File name = %s \n", sitecsv);
      break;
    case 'c':
      start_site_id = atol(optarg); //need to change to same as 's' type to prevent segfault when not specified argument
      printf("Site ID CC to Hunt For = [%lld] \n", start_site_id);
      break;
    case 'g':
      if (optarg[0] == '-') {
        printf("Error: -%c: option requires an argument\n", c);
        print_usage(argv[0]);
      }
      groupcsv = optarg;
      printf("Group CSV File name = %s \n", groupcsv);
      break;
    case 'r':
      if (optarg[0] == '-') {
        printf("Error: -%c: option requires an argument\n", c);
        print_usage(argv[0]);
      }
      rfgain = atoi(optarg);
      printf("RF Gain = %d \n", rfgain);
      break;  
    case 'p':
      adjust = 1;
      printf("AFC/PPM auto adjust enabled - warning, highly temperamental \n");
      break;
    }
  }
}

//--------------------------------------------MAIN--------------------------------------
int main(int argc, char ** argv) {
  setlocale(LC_ALL, "");  
  ENT();
  cc = 0;
  groupcsv = "group.csv";
  sitecsv = "site.csv";

  ParseInputOptions(argc, argv);
  signed int avg = 0; //sample average
  s_len = 11 - (a_len + f_len);
  if (x_choice == 2)
  {
    printf("Subfleet bit setting = [%X] bits \n", s_len);
    for(unsigned short int i=0; i<a_len; i++)	//A
    {
	  a_mask=a_mask<<1;
	  a_mask|=1;
    }
    a_mask=a_mask<<(11-a_len);
    printf("a_mask = [%X] \n", a_mask);	
    for(unsigned short int i=0; i<f_len; i++)	//F
    {
	  f_mask=f_mask<<1;
	  f_mask|=1;
    }
    f_mask=f_mask<<s_len;
    printf("f_mask = [%X] \n", f_mask);	
    for(unsigned short int i=0; i<s_len; i++)	//S
    {
	  s_mask=s_mask<<1;
	  s_mask|=1;
    }
    printf("s_mask = [%X] \n", s_mask);
  }
  init_udp();

  sleep(1); //patience is a virtue	
  //if gain specified by user, then change gain in PyEDACS from default value
  if (rfgain > 0) {
    gainSet(rfgain);  
  }
  //When using PyEDACS and changing site you want to monitor, this will set to a presumably empty channel so it won't be stuck on the last monitored channel
  if (start_site_id > 0) {
      tuneCC(850000000);
  }
  last_sync_time = time(NULL);
  last_voice_time = time(NULL);
  unsigned char voice_to = 0; //0 - no timeout active, 1 - last voice channel assignment more than VOICE_TIMEOUT seconds ago, inactive

  for (int i = 0; i < SAMP_NUM / 2 / 3 - 1; i++) //zero array
  {
    avg_arr[i] = 0;
  }

  //let's get the party started
  while (1) {
    initscr(); //Initialize NCURSES screen window
    start_color();
    init_pair(1, COLOR_YELLOW, COLOR_BLACK);
    init_pair(2, COLOR_MAGENTA, COLOR_BLACK);
    init_pair(3, COLOR_CYAN, COLOR_BLACK);
    noecho();
    cbreak();

    if ((time(NULL) - last_sync_time) > SYNC_TIMEOUT) //check if the CC is still there
    {
      erase();
      attron(COLOR_PAIR(2));
      for (short int i = 0; i < 13; i++) {
        printw("%s \n", FM_banner[i]);
      }
      attroff(COLOR_PAIR(2));
      printw("Control Channel not found/lost. Timeout. Waiting...\n");

      squelchSet(5000); //mute, may remove if condition of control channel lost during voice active
      last_sync_time = time(NULL);
      kicked = 0;
      targetp = 0;
      sourcep = 0;
      peer = 0;
      patch_site = 0;
      tempsite_id = 999;
      active = 0;
      if (start_site_id == 0){
        site_id = 0;
        site_name = "Searching";
        location_name = "Searching";
      }
      if (start_site_id > 0) {
        printw("Attemping to tune Site [%d] LCNs to find Control Channel\n", start_site_id);
        site_id = start_site_id;
        csvImport();
        if (cyclecc > -1 && cyclecc < 31) { //cycle through a possibility of 32 LCN channels in the sites.csv file
          if (LCN_list[cyclecc] > 1) {
            tuneCC(LCN_list[cyclecc]);
            printw("LCN Freq: [%d]", LCN_list[cyclecc]);
            cyclecc = cyclecc + 1;
            refresh();
            sleep(2);
          }
        }
        if (LCN_list[cyclecc]==0) { //if no more frequencies in sites.csv, jump back to beginning of cycle
          cyclecc = 0;
        }
        if (cyclecc > 31) {  //if cyclecc exceeds 31, jump back to beginning, assuming there are 32 LCN channels specified
          cyclecc = 0;
        }
      }
      refresh();

    }

    read(0, samples, 3 * 2); //read 3 samples (6 unsigned chars)
    raw_stream[0] = (signed short int)((samples[0 + 1] << 8) | (samples[0] & 0xFF));
    raw_stream[1] = (signed short int)((samples[2 + 1] << 8) | (samples[2] & 0xFF));
    raw_stream[2] = (signed short int)((samples[4 + 1] << 8) | (samples[4] & 0xFF));
    avg = (raw_stream[0] + raw_stream[1] + raw_stream[2]) / 3; //

    //AFC recomputing using averaged samples
    avg_arr[avg_cnt] = avg;
    avg_cnt++;
    if (avg_cnt >= SAMP_NUM / 2 / 3 - 1) //reset after filling avg_array
    {
      avg_cnt = 0;
      min = SHRT_MAX;
      max = SHRT_MIN;

      for (int i = 0; i < SAMP_NUM / 2 / 3 - 1; i++) //simple min/max detector
      {
        if (avg_arr[i] > max)
          max = avg_arr[i];
        if (avg_arr[i] < min)
          min = avg_arr[i];
      }
      AFC = (min + max) / 2;
      
    }
    //--------------------------------------

    //pushing data into shift registers
    sr_0 = (sr_0 << 1) | (sr_1 >> 63);
    sr_1 = (sr_1 << 1) | (sr_2 >> 63);
    sr_2 = (sr_2 << 1) | (sr_3 >> 63);
    sr_3 = (sr_3 << 1) | (sr_4 >> 63);
    sr_4 = sr_4 << 1;

    if (avg < AFC)
      sr_4 |= 1;
    //---------------------------------

    if ((sr_0 & SYNC_MASK) == SYNC_FRAME) //extract data after receiving the sync frame
    {
      //put sr data in human readable/easier to work with fr 40 bit (10 hex) messages
      fr_1 = ((sr_0 & 0xFFFF) << 24) | ((sr_1 & 0xFFFFFF0000000000) >> 40);
      fr_2 = sr_1 & 0xFFFFFFFFFF;
      fr_3 = (sr_2 & 0xFFFFFFFFFF000000) >> 24;
      fr_4 = ((sr_2 & 0xFFFFFF) << 16) | ((sr_3 & 0xFFFF000000000000) >> 48);
      fr_5 = ((sr_3 & 0xFFFFFFFFFF00) >> 8);
      fr_6 = ((sr_3 & 0xFF) << 32) | ((sr_4 & 0xFFFFFFFF00000000) >> 32);
      if (fr_1 == fr_3 && fr_4 == fr_6) //error detection up top to trickle down
      {
        command = ((fr_1 & 0xFF00000000) >> 32) ^ x_mask;
        if (x_choice == 1){
            lcn = (fr_1 & 0x3E0000000) >> (27 + lshifter); 
            //lcn = ((fr_1 & 0xF8000000) >> 27); //going to try just like for legacy just for fun...NOPE
            xstatus = (fr_1 & 0x7C00000) >> 22;
        }
        
        if (x_choice == 2){  //funky formatting is for easier visualizing on where to apply masking
         status = (fr_1 &0xF00000000) >> 32;
            lcn = (fr_1 & 0xF8000000) >> 27;
              afs = (fr_1 & 0x7FF000) >> 12;
        //a_mask = 0x780; 4
        //f_mask = 0x078; 4 
        //s_mask = 0x007; 3
        //AFS =  0x625 <- first hex always has to be 7 or less, so don't mask with F, mask with 7
        //4      0x780 >> 3 + 4 or (11 = a_len) 
        //3      0x0F0 >> 4 + 1 or (f_mask << s_len)
        //4      0x00F just use afs & a_mask
        agency = (afs & a_mask) >> (11 - a_len); //this one is correct
        fleet = (afs & f_mask) >> s_len; //this is also correct, assuming mask is correct
        subfleet = (afs & s_mask);
              if (status == 0xE){
           sender = (fr_1 & 0x7FF000) >> 12;} //Not quite sure when/where to grab this variable in the FR and which statuses
 
        }
        
        mt1 = command >> 3;
        mt2 = (fr_1 & 0x780000000) >> 31;
        //step below probably needs fixing for EA sites without ESK
        if ((fr_1 & 0xFFF0000000) == 0x5D00000000 && x_choice == 1 || (fr_1 & 0xFFF0000000) == 0x5D60000000 && x_choice == 1) //Site ID, some SL*** sites seem to use 0x5D6 and not 5D0, maybe lower ID sites, backwards compatibility?
        {
          site_id = ((fr_1 & 0x1F000) >> 12) | ((fr_1 & 0x1F000000) >> 19);
          if (site_id != tempsite_id) {
            csvImport();
            tempsite_id = site_id;
          }
        }
        if (command == ID_CMD && x_choice == 2){
            site_id = (fr_1 & 0xFF000) >> 12;
            if (site_id != tempsite_id) {
              csvImport();
              tempsite_id = site_id;
              //continue;  
            }
        }
        if (command == PATCH_CMD && (fr_1 & 0xFF00000000) == 0x5E00000000) //ADD LISTING 
        {
          patch_site = ((fr_4 & 0xFF00000000) >> 32);
          targetp = ((fr_4 & 0xFFFF000) >> 12);
          sourcep = ((fr_1 & 0xFFFF000) >> 12);
        }
        if (command == DATA_CMDX && (fr_1 & 0xFF00000000) == 0x5B00000000) //KICK LISTING 
        {
          kicked = (fr_4 & 0xFFFFF000) >> 12;
        }
        if (x_choice == 1 && command == IDLE_CMD) //setting this to ID_FR to investigate these frames for now, remove later
        {
          ID_FR1 = fr_1;
          ID_FR4 = fr_4;
          if (((fr_4 >> 12) & 0x1F) != 0){
            CC_LCN = ((fr_4 >> 12) & 0x1F);
            if (CC_LCN > lcn_tally){lcn_tally=CC_LCN;}
          }
        }

        if (x_choice == 2 && command == 0xFD){
          CC_LCN = (fr_1 & 0x1F000000) >> 24;}  

      //-------------------------------------------------

      last_sync_time = time(NULL); //set timestamp
      print_timeri = print_timeri - 1; //primitive timer for printing out IDLE status updates
      if (command == idcmd && print_timeri < 0 )//IDLE, Florida Man don't want no print timer bullshit'
      {

        if (voice_to == 0) //1 for inactive (backwards, I know)
        {
          squelchSet(5000); //if LCN is activated below, this will not hang up LCN until resuming, on busy systems using hanguptime to hang up after 10 seconds
          voice_to = 1; //1 - idle
        }
        erase();
        attron(COLOR_PAIR(1));
        for (short int i = 0; i < 13; i++) {
          printw("%s \n", FM_banner[i]);
        }  
        attroff(COLOR_PAIR(1));
        printw("%s  AFC=[%d]Hz\n", getTime(), AFC);
        printw("Site ID=[%3lld][%2llX] Location: %s\n", site_id, site_id, location_name);
        if (x_choice == 2) {
            printw("Status Bits = ", status);
            for (unsigned short int i = 0; i < 4; i++) {
              signed short int buffer = (status >> 3 - i) & 0x1;
              printw("[%1d] ", buffer);
              
            }
            printw("\n");
            //printw("SR_0 = %16llX \n", sr_0); //leaving here in case I need to do some more debugging
            //printw("SR_1 = %10llX \n", sr_1);
            //printw("FR_1 = %10llX \n", fr_1);
            //printw("FR_4 = %10llX \n", fr_4);
        }
        if (x_choice == 1) {
            printw("MT-1 ");
            for (unsigned short int i = 0; i < 5; i++) {
              signed short int buffer = (mt1 >> 4 - i) & 0x1;
              printw("[%1d] ", buffer);
            }
            printw("\n");
            printw("MT-2 ");
            for (unsigned short int i = 0; i < 4; i++) {
              signed short int buffer = (mt2 >> 3 - i) & 0x1;
              printw("[%1d] ", buffer);
            }
        printw("\n");
        }
        for (short int i = 0; i < lcn_tally; i++) {
          printw("LCN[%2d]", lcn_tally - (lcn_tally-1) + i);
          printw("[%lldHz] ", LCN_list[i]);
          if (x_choice == 1 && CC_LCN == (i+1)){
              attron(COLOR_PAIR(1));
              printw("Control Channel");
              attroff(COLOR_PAIR(1));
          }
         printw("\n");
        }  
        refresh();
        // Start AFC/PPM Adjustment testing code
        if (adjust == 1) {
          if (AFC < -1000) {
          ppm = 1; //need to adjust to 0.1 instead, need to change type first
          ppmAdjust(ppm); //on the PyEDACS side, this value is added to ppm value already asserted to dongle
          sleep(3); //wait for adjustment to take effect, may need to use 2 instead
          }
          if (AFC > 1000) {
          ppm = -1; //need to adjust to 0.1 instead, need to change type first
          ppmAdjust(ppm); //on the PyEDACS side, this value is added to ppm value already asserted to dongle
          sleep(3); //wait for adjustment to take effect, may need to use 2 instead
          }
        }
      // End AFC/PPM Adjustment testing code, most likely will get axed if not working at some point soon
      } 
      if ((fr_1 & 0xFFF0000000) == 0x5880000000 && ((fr_1 & 0xFF000) >> 12) > 0){ //PEER Listing
        peer = (fr_1 & 0xFF000) >> 12; }
        
        
      if (x_choice ==1 && (command == vcmd || command == 0xA8 || command == 0xB0 || command == 0x90) || (x_choice == 2 && (command == 0xEE || command == 0xEF ) ) ) { 

        if ( (x_choice == 1 && lcn > lcn_tally && mt1 == 0x3) || ( lcn > lcn_tally && x_choice == 2) ) {lcn_tally=lcn;}  //only increment LCN channel list on 0x3 for testing, revert later when 0x2 and 0x1 are figured out properly
        voice_to = 0;   //0-active
        deny_flag = 0; //reset trip on deny_flag
        allow = 0;     //reset trip on alow flag during universal denial
        if (fr_1 == fr_3 && fr_4 == fr_6) //error detection for groupx, senderx, xstatus variables, probably redundant
        {
          groupx = (fr_1 & 0xFFFF000) >> 12;
          if (x_choice == 2){
            groupx = afs;  
          }
          if (tgroupx != groupx) {
            tgroupx = groupx;
            csvGroupImport();
          }

          senderx = (fr_4 & 0xFFFFF000) >> 12;
          //if the sender isn't identical and 1 second last voice difference, test to see if this works correctly, may not log call if call occurs during startup
          if (tsenderx != senderx && (time(NULL) - last_voice_time > 1) && x_choice == 1) 
          {
            FILE * pFile;
            pFile = fopen("voice.log", "a");
            fprintf(pFile, "%s %s \tSITE %3lld \tLCN %2d \tTG %5lld \tRID %lld  \n", getDate(), getTime(), site_id, lcn, groupx, senderx);
            fclose(pFile);
            tsenderx = senderx;
          }
          
          if (tafs != afs && x_choice == 2 && site_id > 0 && (time(NULL) - last_voice_time > 1) ) //currently will not log same AFS using multiple LCNs in succession, weird splat happens in afs.log on startup
          {
            FILE * pFile;
            pFile = fopen("afs.log", "a");
            
            if (status == 0xF){
                fprintf(pFile, "%s %s \tSITE %3lld \tLCN %2d \tAFS[%4lld][%d-%d-%d]\tDigital\n", getDate(), getTime(), site_id, lcn, afs, agency, fleet, subfleet);
            }
            if (status == 0xE){
                fprintf(pFile, "%s %s \tSITE %3lld \tLCN %2d \tAFS[%4lld][%d-%d-%d]\tAnalog\n", getDate(), getTime(), site_id, lcn, afs, agency, fleet, subfleet);
            }
            fclose(pFile);
            tafs = afs;
          }

        }
        if (lcn == current_lcn) //lcn==current_lcn
        {
          last_voice_time = time(NULL);

        } 
          print_timeri = 100;
          erase();
          attron(COLOR_PAIR(3));
          for (short int i = 0; i < 13; i++) {
            printw("%s \n", FM_banner[i]);
          }  
          attroff(COLOR_PAIR(3));
          printw("%s  AFC=[%d]Hz\n", getTime(), AFC);
          printw("Site ID=[%3lld][%2llX] Location: %s\n", site_id, site_id, location_name);
          if (x_choice == 2) {
            printw("Status Bits = ", status);
            for (unsigned short int i = 0; i < 4; i++) {
              signed short int buffer = (status >> 3 - i) & 0x1;
              printw("[%1d] ", buffer);
              
            }
            printw("\n");
          }
          if (x_choice == 1) {
            printw("MT-1 ");
            for (unsigned short int i = 0; i < 5; i++) {
              signed short int buffer = (mt1 >> 4 - i) & 0x1;
              printw("[%1d] ", buffer);
            }
            printw("\n");
            printw("MT-2 ");
            for (unsigned short int i = 0; i < 4; i++) {
              signed short int buffer = (mt2 >> 3 - i) & 0x1;
              printw("[%1d] ", buffer);
              
            }
            printw("\n");
          }
          for (short int i = 0; i < lcn_tally; i++) {
            printw("LCN[%2d]", lcn_tally - (lcn_tally-1) + i);
            printw("[%lldHz] ", LCN_list[i]);
            if (CC_LCN == (i+1)){
              attron(COLOR_PAIR(1));  
              printw("Control Channel");}
              attroff(COLOR_PAIR(1));
            if (x_choice == 1 && lcn == (i+1)){
                attron(COLOR_PAIR(3));
                printw("RID[%lld] TG[%lld][%s][%s] ", senderx, groupx, groupx_name, mode);
                if (mt1 == 0x3){
                    printw("Digital");
                }
                if (mt1 == 0x2){
                    printw("Data");
                }
                if (mt1 == 0x1){
                    printw("TDMA");
                }
                if (mt1 == 0x4){
                    printw("Analog"); //putting 0x4 for now, find out what Analog should be, if it exists
                }
                attroff(COLOR_PAIR(3));
            }
            if (x_choice == 2 && lcn == (i+1)){
                attron(COLOR_PAIR(3));
                printw("AFS[%lld][%d-%d-%d][%s][%s]", afs, agency, fleet, subfleet, groupx_name, mode);
                if (status == 0xE){
                  printw("Analog");}
                if (status == 0xF){
                  printw("Digital");} 
                attroff(COLOR_PAIR(3));
            }
            printw("\n");
          }  
          refresh();
          //add more modes for blocking, block groups, may have to just skip allow only groups until universal deny thing exists again  
          mode_a = "DE"; //Digital Encrypted from csv, blocking
          mode_b = mode;
          modecompare = strcmp(mode_a, mode_b);
          if (modecompare == 0) {
            deny_flag = 1;
            current_lcn = lcn; //not sure if should use this or not, will test <- initial tests seem good, continue to test
          }
          mode_a = "B"; //Blocked Group from csv
          modecompare = strcmp(mode_a, mode_b);
          if (modecompare == 0) {
            deny_flag = 1;
            current_lcn = lcn; //not sure if should use this or not, will test <- initial tests seem good, continue to test
          }
          if (udeny == 0 && deny_flag == 0 && lcn != current_lcn && voice_to == 0) //tune to LCN if lcn didn't change and voice_to is active
          {
            tune(LCN_list[lcn - 1]);
            current_lcn = lcn;
            squelchSet(0); //unmute
            //voice_to=0; // voice_to = 0 is for active
            hanguptime = time(NULL); // trying this really quick
          }
          
          mode_a = "A"; //Allow Group from csv
          modecompare = strcmp(mode_a, mode_b);
          if (modecompare == 0) {
            allow = 1;
            current_lcn = lcn; //not sure if should use this or not, will test <- initial tests seem good, continue to test
            
          }
          if (udeny == 1 && allow == 1) //tune to LCN if if univeral denial active and allowed group
          {
            tune(LCN_list[lcn - 1]);
            current_lcn = lcn;
            squelchSet(0); //unmute
            hanguptime = time(NULL); // trying this really quick
            //voice_to=0; // voice_to = 0 is for active
          }
          if ((time(NULL) - hanguptime) > 10){ //should look into making hangup time a user defined variable
              squelchSet(5000);
          }

        refresh();
      } //this once closes vcmd
    } //this one closes the fr_1 == fr_3 && fr_4 == fr_6 if condition, make sure it stays that way

    } //this one closes the sync frame if statement, make sure it stays that way
    else {} //no idea why I have this one, not sure if I need it or not
  }

  endwin(); //terminae NCURSES screen
  return 0;
}
